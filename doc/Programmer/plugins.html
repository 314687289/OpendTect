<html>
<!--
  - CopyRight:	(C) dGB Earth Sciences
  - Author:	A.H. Bril
  - Date:	Oct 2003
  - Contents:	Plugins
  - RCS:	$Id: plugins.html,v 1.9 2003-11-02 22:37:59 bert Exp $
 -->

<body background="../backg.png"><title>Plugins [OpendTect Programmer's manual V1.0]</title>
<center>
<h1>OpendTect Plugins</h1>
  <a href=#intro>Intro</a>
| <a href=#concept>Concept</a>
| <a href=#mnudlg>Menu and Dialog</a>
| <a href=#coh>Coherency</a>
</center>
<br>
<img src="../hr.png" border=0>

<a name=intro><h2>Intro</h2>
<h3>Background</h3>
<p>
Making your own software within OpendTect is in principle pretty easy. You <i>could</i> change the software by modifying existing classes and functions, and adding your own stuff to the libs. The advantage is total control. The problem with this approach, however, is that you have to keep the OpendTect sources in sync with new releases. Furthermore, if you cannot convince the opendtect.org people also make those changes, OpendTect users may not be happy with your work.
</p><p>
An easy way to overcome this is to make your own plugins. Plugins make use of all the facilities of OpendTect but are loaded at run-time and can therefore be developed in a completely independent way. If you then find things that can't be done without modifying the OpendTect environment, it should be much easier to convince the opendtect.org people to take over or even implement those things themselves.
</p><p>
One thing you <i>cannot</i> do, is use another compiler than <b>gcc/g++</b>. OpendTect is built with it, if you want to use another compiler (why?) you'll have to make all libs and supporting libs (Qt, COIN) yourself. The make itself should be pretty easy to get started, but there will probably be some porting to do, too.
</p>

<br><br>
<a name=concept><h2>The concept</h2>
<h3>Dynamic loading</h3>
<p>
All modern Operating systems nowadays have ways to dynamically load libraries into a running program. The basic idea is:
<ul>
<li>Open the library
<li>Query the contents for a certain routine using a string key
<li>Call the routine returned
<li>The routine then does the things needed to make itself useful.
</ul>
</p><p>
As an example, a 'hello world' program could conceptually look like this:
<pre><code>dynlib = OpenDynamicLib( "libc.so" );
PrintfTypeFunction fn = (PrintfTypeFunction)GetDynLibFn( dynlib, "printf" );
fn( "Hello world" );
</code></pre>
</p><p>
In this very simple case calling the function has no other effect than printing a string. In OpendTect, you'd want to add an attribute, create a menu item in the Opendtect menu, etc. etc.
</p>

<h3>OpendTect plugins</h3>
<p>
In OpendTect, all of the dynamic lib querying etc. is already programmed. A plugin just needs to contain a few standard functions that will be called automatically when the dynamic library is loaded. There are three functions, of which only one is really required. Let's say the name of the plugin is MyMod, these functions will be:
<pre><code>GetMyModPluginType
GetMyModPluginInfo
InitMyModPlugin
</code></pre>
Only the last one is required. The first one, <code>Get...PluginType</code> determines whether the plugin can be used for the auto-load, and if so, when. 'When' means: before or after the program has created its own objects (but always after the static objects are initialised). The second function simply provides info for the users of your plugin.
</p><p>
Note that these functions must be declared 'extern "C"', as you can see in the first example plugin "Hello":
<pre><code>#include &lt;iostream&gt;
extern "C" const char* InitHelloPlugin( int, char** )
{
    std::cout &lt;&lt; "Hello world" &lt;&lt; std::endl;
    return 0; // All OK - no error messages
}
</code></pre>
You'll find this example plugin in the plugins directory. Those 6 lines are enough to constitue a plugin for OpendTect. The Makefile to build the plugin looks like this:
<pre><code>SRC.cc := hellopi.cc
PLUGIN := yes
include make.od.Defaults
include make.Targets
</code></pre>
First try <code>make -n</code>. Notice that Pmake makes an awful lot of commands with a small specification. Anyway, after typing <code>make</code> the plugin should be generated. The new plugin can be loaded from within OpendTect (Menu Utilities-Plugins; press the 'Load new' button). At that point in time, the message 'Hello world' should appear on stdout (wherever that may be on Windows).
</p><p>
To make this a UI - based program we'll need to use functionality from the <code>uiBase</code> module. In this case, we use the <code>uiMSG()</code> utility:
<pre><code>#include "uimsg.h"
extern "C" const char* InituiHelloPlugin( int*, char** )
{
    uiMSG().message( "Hello world" );
    return 0; // All OK - no error messages
}
</code></pre>
Again 6 lines, but now, when you load it, you'll get a popup message with an OK button.
</p>
In this case we actually use stuff from OpendTect libraries, so the Makefile needs to change. We need to add the line:
<pre><code>MODDEP := uiBase
</code></pre>
Notice that this is added <i>before</i> the inclusions: It's a directive to establish all kinds of variables in the make includes. By typing <code>make -n</code> again you'll see that Pmake added some directives for the compiler.
</p>

<br>
<a name=real><h2>Realistic examples</h2>

<a name=mnudlg><h3>Menu and Dialog</h3>

<h4>Intro</h4>
<p>
Adding menu items popping up your own dialogs is pretty easy once you get the hang of it. The uiArkCls plugin is a good example: it shows how to get hold of the parent menus, and what to do to get the CallBacks. You don't need to download the doc.arkcls however because the uiHello plugin code contains some example code to make things clear. Although we fear that you mmight be scared by this code when you first see it, we hope that after the explanations below you will see some beauty in it and start to like it.
</p><p>
Look in uihellopi.cc - the PLAN_B part. First of all, we nicely define the other standard plugin functions:
<pre><code>extern "C" int GetuiHelloPluginType()
{
    return PI_AUTO_INIT_LATE;
}

extern "C" PluginInfo* GetuiHelloPluginInfo()
{
    static PluginInfo retpi = {
        "uiHello plugin - plan B",
        "Bert",
        "1.0.1",
        "This is the more extensive variant of the uiHello example.\n"
        "See the plugin manual for details." };
    return &retpi;
}
</pre></code>
 The plugin will now load automatically when put in the <code>plugins/$HDIR</code> directory in the installation, or the <code>.od</code> subdirectory of your home dir.
</p><p>
The idea is to add a menu item 'Display Hello Message ...' to the 'Utilities' menu of OpendTect. The Makefile and the example code are already prepared for this, you only need to define 'PLAN_B', for example on the command line:
<code><pre>make PLAN_B=yes</code></pre>
Apart from adding a flag so we can check for PLAN_B in the code, the <code>MODDEP := uiApplMan</code> tells Pmake that the <code>uiApplMan</code> headers, and the headers <code>uiApplMan</code> depends on will be used. That is much more than the original <code>uiBase</code> dependencies.
</p><p>
<h4>Problems</h4>
The two problems we are faced with are:
<ol>
<li>How to create a new menu item
<li>How does one make a new dialog
</ol>
The real problem behind the first is not so much how to make the item itself, but how to get hold of the parent menu it must be inserted into. The problem with that is that at the time of the plugin initialisation, the menu itself may not yet exist. That is why, in that case, we have to ask the OpendTect UI Manager object (The uidTectMan instance) whether it is already finalised, and if not, to give us a callback when it does. Otherwise, we can simply insert the item:
<pre><code>if ( mgr->applman->uidMan()->isFinalised() )
    mgr->init( mgr->applman->uidMan() );
else
    mgr->applman->uidMan()->finalised.notify(mCB(mgr,uiHelloMgr,init));
</pre></code>
Because callbacks can only be sent to objects that are <code>CallBacker</code>s, we have made an object <code>uiHelloMgr</code> that can receive the callback from the menu.
</p>
<h4>The <code>uiHelloMgr</code></h4>
<p>
The uiHelloMgr will receive a callback when the ui manager is finalised: the <code>init(CallBacker*)</code> method is then called. In that method the ui hello manager inserts the menu item into the menu. It tells the menu item to call the dispMsg method when triggered:
<code><pre>applman->utilMnu()->insertItem(
      new uiMenuItem( "&amp;Diplay Hello Message ...",
                      mCB(this,uiHelloMgr,dispMsg) );
</code></pre>
The <code>uiHelloMgr::dispMsg</code> method does nothing more than make an instantiation of the dialog class we made for showing the message: <code>uiHelloMsgBringer</code>.
</p>
<h4>The <code>uiHelloMsgBringer</code></h4>
<p>
The <code>uiHelloMsgBringer</code> class is a <code>uiDialog<code> which means it has (by default) Ok and Cancel buttons, a window title, and so forth. The class contains a field for user input of the string to display as message. To make the example a bit lively, we added a field whether the message should be, eh, just a message, or a warning. You can see the <code>uiGenInput</code> class will serve both input fields nicely, you just need to define another <code>InpSpec</code> instance:
<code><pre>txtfld = new uiGenInput( this, "Hello message",
                                    StringInpSpec("Hello world") );
    typfld = new uiGenInput( this, "Message type",
                             BoolInpSpec("Info","Warning") );
    typfld->attach( alignedBelow, txtfld );
</code></pre>
Note that "Hello world" is the inital string displayed in <code>txtfld</code>. Another feature of the OpendTect UI is the automatic layout: we program the positions of the various fields by attaching them in certain ways - most commonly <code>alignedBelow</code>.
</p><p>
The actual message is displayed when the user presses Ok on the dialog that pops up. When nothing is filled in, we give the user the finger with the "Please type a text" message, and we do not accept the Ok, i.e. the dialog remains on the screen and the user can either be a good girl (or boy) and fill in something or press cancel.
<code><pre>if ( ! *typedtxt )
{
    uiMSG().error( "Please type a text" );
    return false;
}
</code></pre>
When a message is present, we do as we're told:
<code><pre>if ( typfld->getBoolValue() )
    uiMSG().message( typedtxt );
else
    uiMSG().warning( typedtxt );
return true;
</code></pre>
and the dialog disappears immediately after the message appears on the screen.

</p>

<br>
<a name=coh><h3>Attributes: Coherency</h3>

<a name=cohintro><h4>Intro</h4>
<p>
Anyone vaguely familiar with interpretation should by now know about Coherency abd Coherency cubes. We have always used the 'Similarity' attribute instead because of patent restrictions. Similarity is just as good for object detection en better suited in combination with the dip/steering concept. Coherency beats Similarity when used for single-attribute display.
</p><p>
The Coherency attributes were implemented some time ago by Kristofer for his research work, and it seemed a good idea to show how to make your own attribute plugins by looking at the <code>Coh</code> and <code>uiCoh</code> plugin code.
</p>

<a name=cohrw><h4>The <code>Coh</code> plugin</h4>
<p>
The <code>Coh</code> plugin handles the 'Real Work' part. If we start with the plugin 'main' file, <code>uicohpi.cc</code>, we see that it's not that much more complex than the <code>hellopi.cc</code> from the <code>Hello</code> plugin. There are three includes:
<code>#include "coh.h"</code> gets the Coherency attribute object classes;
<code>#include "attribfact.h"</code> gets the attribute factory to which the Coherency attributes must be added;
<code>#include "plugins.h"</code> is needed for the PluginInfo structure and teh PI_AUTO_INIT_EARLY define:
<pre><code>extern "C" int GetCohPluginType()
{
    return PI_AUTO_INIT_EARLY;
}</code></pre>
The above is one of the three 'special' plugin functions that determine how OpendTect will deal with the plugin. The GetxxxxPluginType() function is used for detemining whether and when to auto-load the plugin. The auto-load tool of OpendTect looks for plugins to load in two places: The plugins/platform_dir of the installation directory (<code>$DTECT_APPL/plugins/$HDIR</code>) and the same on the HOME directory (or <code>Application data</code> on windows).
</p><p>
This particular plugin tells OpendTect's application manager that it wants to be loaded early - i.e. before any build of tables, data structures or user interfaces are made. That is typical of 'Real Work' plugins. The alternatives are NONE (which is default so in that case a GetxxxxPluginType() need not be defined and LATE, which is typical for UI plugins that want to start working when most of the widgets are already created.
</p><p>
A few lines further we get:
<pre><code>extern "C" PluginInfo* GetCohPluginInfo()
{
    static PluginInfo retpii = {
        "Coherency",
        "dGB - Kristofer Tingdahl and Bert Bril",
        "1.0.1",
        "Coherency attribute plugin.\n\n"
        "Usage of Coherency may be subject to patent laws!" };
    return &retpii;
}</code></pre>
If you look at the definition of PluginInfo, this should be easy to grasp. It allows the plugin manager to make this info about the plugin available to the world.
</p><p>
The actual work is done, like in the Hello world plugin, in:
<pre><code>extern "C" const char* InitCohPlugin( int, char** )
{
    AF().add( new CoherencyAttrib::Parameters, false );
    return 0; // All OK - no error messages
}</code></pre>
This function gets passed argc and argv from the main function. It should return null on success, and an error message if the initialisation failed. In this case, the Coherency attribute is added to AF() (the <a href="Generated/AttribEng/classAttribFactory.html">AttribFactory</a> singleton access function) using the macro defined in attribfact.h .
</p>

<a name=cohrw><h4>Making attributes</h4>
<p>
Although cohpi.cc looks pretty simple, underneath the simple <code>AF().add</code> there is of course some real programming of the attribute. For that, we need to switch to coh.h . We see an attribute <code>CoherencyAttrib</code> inheriting the <a href="Generated/AttribEng/classAttribCalc.html">AttribCalc</a> class. Then immediately an enormous macro (in OpendTect macros can often be recognised by the leading 'm') <code>mAttrib5Param</code> which defines the parameters of the attribute. Compare this to what you see in Opendtect in the attribute definition window after loading the uiCoh plugin.
</p><p>
If you look at the parts of the definition carefully, you'll see that each parameter is built up with:
<ul>
<li>xxxxAttribParameter - the type of the parameter
<li>the name of the parameter
<li>Required, Default (or Disabled)
<li>The default value
<li>The allowed values
</ul>
</p><p>
Most of the rest of the methods are there to comply with the <code>AttribCalc</code> interface - see the <a href="Generated/AttribEng/classAttribCalc.html">AttribCalc documentation</a>.
MORE
</p><p>
On the implementation side of all that, we have some overhead and the actual attribute calculation. If you feel that the overhead is enormous, bear in mind that the Attribute engine will let the attribute work on any part of any input cude or on the output of another attribute, and that things are cut in pieces when multiple processors are available. And there's more but the idea is that all that requires some extra work when making the attributes.
</p><p>
When we want to look at the actual work, the place to be is the <code>nextStep()</code> method of the <code>CoherencyAttrib::Task</code> class.
MORE
</p>



<img src="../hr.png" border=0>

<p>
<center>
  <a href="index.html">Index</a>
| <a href="overview.html">Overview</a>
| <a href="pmake.html">Pmake</a>
| <a href="http://www.opendtect.org">opendtect.org</a>
</center>
</p>

</body>
</html>
