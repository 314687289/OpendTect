<html>
<!--
  - CopyRight:	(C) dGB Earth Sciences
  - Author:	A.H. Bril
  - Date:	Oct 2003
  - Contents:	Plugins
  - RCS:	$Id: plugins.html,v 1.4 2003-10-30 15:54:17 bert Exp $
 -->

<body bgcolor="#dddddd"><title>Plugins [OpendTect Programmer's manual V1.0]</title>
<center>
<h1>OpendTect Plugins</h1>
  <a href=#intro>Intro</a>
| <a href=#concept>Concept</a>
| <a href=#real>Real examples</a>
</center>
<br>
<hr size=3>

<a name=intro><h2>Intro</h2>
<h3>Background</h3>
<p>
Making your own software within OpendTect is in principle pretty easy. You <i>could</i> change the software by modifying existing classes and functions, and adding your own stuff to the libs. The advantage is total control. The problem with this approach, however, is that you have to keep the OpendTect sources in sync with new releases. Furthermore, if you cannot convince the opendtect.org people also make those changes, OpendTect users may not be happy with your work.
</p><p>
An easy way to overcome this is to make your own plugins. Plugins make use of all the facilities of OpendTect but are loaded at run-time and can therefore be developed in a completely independent way. If you then find things that can't be done without modifying the OpendTect environment, it should be much easier to convince the opendtect.org people to take over or even implement those things themselves.
</p>

<br><br>
<a name=concept><h2>The concept</h2>
<h3>Dynamic loading</h3>
<p>
All modern Operating systems nowadays have ways to dynamically load libraries into a running program. The basic idea is:
<ul>
<li>Open the library
<li>Query the contents for a certain routine using a string key
<li>Call the routine returned
<li>The routine then does the things needed to make itself useful.
</ul>
</p><p>
As an example, a 'hello world' program could conceptually look like this:
<pre><code>dynlib = OpenDynamicLib( "libc.so" );
PrintfTypeFunction fn = (PrintfTypeFunction)GetDynLibFn( dynlib, "printf" );
fn( "Hello world" );
</code></pre>
</p><p>
In this very simple case calling the function has no other effect than printing a string. In OpendTect, you'd want to add an attribute, create a menu item in the Opendtect menu, etc. etc.
</p>

<h3>OpendTect plugins</h3>
<p>
In OpendTect, all of the dynamic lib querying etc. is already programmed. A plugin just needs to contain a few standard functions that will be called automatically when the dynamic library is loaded. There are three functions, of which only one is really required. Let's say the name of the plugin is MyMod, these functions will be:
<pre><code>GetMyModPluginType
GetMyModPluginInfo
InitMyModPlugin
</code></pre>
Only the last one is required.
</p><p>
Note that these functions must be declared 'extern "C"', e.g.:
<pre><code>#include <iostream>
extern "C" const char* InitHelloPlugin( int, char** )
{
    std::cout << "Hello world" << std::endl;
    return 0; // All OK - no error messages
}
</code></pre>
This is an example plugin from the plugins directory. Those 6 lines are enough to constitue a plugin for OpendTect. The Makefile to build the plugin looks like this:
<pre><code>SRC.cc := hellopi.cc
PLUGIN := yes
include make.od.Defaults
include make.Targets
</code></pre>
First try <code>make -n</code>. Pmake makes an awful lot of commands with a small specification. Anyway, after typing <code>make</code> the plugin should be generated. The new plugin can be loaded from within OpendTect. At that point in time, the message 'Hello world' should appear on stdout (wherever that may be on Windows).
</p><p>
To make this a UI - based program we'll need to use functionality from the <code>uiBase</code> module. In this case, we use the <code>uiMSG()</code> utility:
<pre><code>#include "uimsg.h"
extern "C" const char* InituiHelloPlugin( int*, char** )
{
    uiMSG().message( "Hello world" );
    return 0; // All OK - no error messages
}
</code></pre>
Again, 6 lines but now, when you load it, you'll get a popup message with an OK button.
</p>
In this case we actually use stuff from OpendTect libraries, so the Makefile needs to change. We need to add the line:
<pre><code>MODDEP := uiBase
</code></pre>
Add this <i>before</i> the inclusions. By typing <code>make -n</code> again you'll see that Pmake added some directives for the compiler.
</p>
<a name=real><h2>Real examples</h2>
<a name=coh><h3>Attributes: Coherency</h3>


<br><hr size=3>

<p>
<center>
  <a href="index.html">Index</a>
| <a href="overview.html">Overview</a>
| <a href="pmake.html">Pmake</a>
| <a href="http://www.opendtect.org">opendtect.org</a>
</center>
</p>

</body>
</html>
