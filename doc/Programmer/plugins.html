<html>
<!--
  - CopyRight:	(C) dGB Earth Sciences
  - Author:	A.H. Bril
  - Date:	Oct 2003
  - Contents:	Plugins
  - RCS:	$Id: plugins.html,v 1.19 2003-12-23 16:03:17 arend Exp $
 -->

<body background="../backg.png"><title>Plugins [OpendTect Programmer's manual V1.0]</title>
<center>
<h1>OpendTect Plugins</h1>
  <a href=#intro>Intro</a>
| <a href=#concept>Concept</a>
| <a href=#mnudlg>Menu and Dialog</a>
| <a href=#coh>Coherency</a>
| <a href=#autoload>Installation and auto-loading</a>
</center>
<br>
<img src="../hr.png" border=0>

<a name=intro><h2>Intro</h2>
<h3>Background</h3>
<p>
Making your own software within OpendTect is in principle pretty easy. You <i>could</i> change the software by modifying existing classes and functions, and adding your own stuff to the libs. The advantage is total control. The problem with this approach, however, is that you have to keep the OpendTect sources in sync with new releases. Furthermore, if you cannot convince the opendtect.org people to also make those changes, OpendTect users may not be happy with your work.
</p><p>
An easy way to overcome this is to make your own plugins. Plugins make use of all the facilities of OpendTect but are loaded at run-time and can therefore be developed in a completely independent way. If you then find things that can't be done without modifying the OpendTect environment, it should be much easier to convince the opendtect.org people to take over or even implement those things themselves.
</p><p>
One thing you <i>cannot</i> do, is use another compiler than <b>gcc/g++</b>. OpendTect is built with it, if you want to use another compiler (why?) you'll have to make all libs and supporting libs (Qt, COIN) yourself. The make itself should be pretty easy to get started, but there will probably be some porting to do, too.
</p>

<br><br>
<a name=concept><h2>The concept</h2>
<h3>Dynamic loading</h3>
<p>
All modern Operating systems nowadays have ways to dynamically load libraries into a running program. The basic idea is:
<ul>
<li>Open the library
<li>Query the contents for a certain routine using a string key
<li>Call the routine returned
<li>The routine then does the things needed to make itself useful.
</ul>
</p><p>
As an example, a 'hello world' program could conceptually look like this:
<pre><code>dynlib = OpenDynamicLib( "libc.so" );
PrintfTypeFunction fn = (PrintfTypeFunction)GetDynLibFn( dynlib, "printf" );
fn( "Hello world" );
</code></pre>
</p><p>
In this very simple case calling the function has no other effect than printing a string. In OpendTect, you'd want to add an attribute, create a menu item in the Opendtect menu, etc. etc.
</p>

<h3>OpendTect plugins</h3>
<p>
In OpendTect, all of the dynamic lib querying etc. is already programmed. A plugin just needs to contain a few standard functions that will be called automatically when the dynamic library is loaded. There are three functions, of which only one is really required. Let's say the name of the plugin is MyMod, these functions will be:
<pre><code>GetMyModPluginType
GetMyModPluginInfo
InitMyModPlugin
</code></pre>
</p><p>
Only the last one is required. The first one, <code>Get...PluginType</code> determines whether the plugin can be used for the <a href=#autoload>auto-load</a>, and if so, when. 'When' means: before or after the program has created its own objects (but always after the static objects are initialised). The second function simply provides info for the users of your plugin.
</p><p>
Note that these functions must be declared 'extern "C"', as you can see in the first example plugin "Hello":
<pre><code>#include &lt;iostream&gt;
extern "C" const char* InitHelloPlugin( int, char** )
{
    std::cout &lt;&lt; "Hello world" &lt;&lt; std::endl;
    return 0; // All OK - no error messages
}
</code></pre>
</p><p>
You'll find this example plugin in the plugins directory. Those 6 lines are enough to constitute a plugin for OpendTect. The Makefile to build the plugin looks like this:
</p><p>
<pre><code>SRC.cc := hellopi.cc
PLUGIN := yes
include make.od.Defaults
include make.Targets
</code></pre>
</p><p>
First try <code>make -n</code>. Notice that Pmake makes an awful lot of commands with a small specification. Anyway, after typing <code>make</code> the plugin should be generated. The new plugin can be loaded from within OpendTect (Menu Utilities-Plugins; press the 'Load new' button). At that point in time, the message 'Hello world' should appear on stdout (on Windows, stdout messages appear on the OpendTect console window).
</p><p>
To make this a UI - based program we'll need to use functionality from the <code>uiBase</code> module. In this case, we use the <code>uiMSG()</code> utility:
<pre><code>#include "uimsg.h"
extern "C" const char* InituiHelloPlugin( int*, char** )
{
    uiMSG().message( "Hello world" );
    return 0; // All OK - no error messages
}
</code></pre>
</p><p>
Again 6 lines, but now, when you load it, you'll get a popup message with an OK button.
</p>
In this case we actually use stuff from OpendTect libraries, so the Makefile needs to change. We need to add the line:
<pre><code>MODDEP := uiBase
</code></pre>
Notice that this is added <i>before</i> the inclusions: It's a directive to establish all kinds of variables in the make includes. By typing <code>make -n</code> again you'll see that Pmake added some directives for the compiler.
</p>

<br>
<a name=real><h2>Realistic examples</h2>

<a name=mnudlg><h3>Menu and Dialog</h3>

<h4>Intro</h4>
<p>
Adding menu items popping up your own dialogs is pretty easy once you get the hang of it. The uiArkCls plugin is a good example: it shows how to get hold of the parent menus, and what to do to get the CallBacks. You don't need to download the doc.arkcls however because the uiHello plugin code contains some example code to make things clear. Although we fear that you might be scared by this code when you first see it, we hope that after the explanations below you will see some beauty in it and start to like it.
</p><p>
Look in uihellopi.cc - the PLAN_B part. First of all, we nicely define the other standard plugin functions:
<pre><code>extern "C" int GetuiHelloPluginType()
{
    return PI_AUTO_INIT_LATE;
}

extern "C" PluginInfo* GetuiHelloPluginInfo()
{
    static PluginInfo retpi = {
        "uiHello plugin - plan B",
        "Bert",
        "1.0.1",
        "This is the more extensive variant of the uiHello example.\n"
        "See the plugin manual for details." };
    return &retpi;
}
</pre></code>
The plugin will now <a href=#autoload>auto-load</a> when put in the correct plugins directory.
</p><p>
The idea is to add a menu item 'Display Hello Message ...' to the 'Utilities' menu of OpendTect. The Makefile and the example code are already prepared for this, you only need to define 'PLAN_B', for example on the command line:
<code><pre>make PLAN_B=yes</code></pre>
Apart from adding a flag so we can check for PLAN_B in the code, the <code>MODDEP := uiApplMan</code> tells Pmake that the <code>uiApplMan</code> headers, and the headers <code>uiApplMan</code> depends on will be used. That is much more than the original <code>uiBase</code> dependencies.
</p><p>
If <code>"make PLAN_B=yes"</code> does not compile anything (because a uiHello.so already exists), you can try to <code>"touch uihellopi.cc"</code> first.
</p><p>
<h4>Problems</h4>
The two problems we are faced with are:
<ol>
<li>How to create a new menu item
<li>How does one make a new dialog
</ol>
The real problem behind the first is not so much how to make the item itself, but how to get hold of the parent menu it must be inserted into. The problem with that is that at the time of the plugin initialisation, the menu itself may not yet exist. That is why, in that case, we have to ask the OpendTect UI Manager object (The uidTectMan instance) whether it is already finalised, and if not, to give us a callback when it does. Otherwise, we can simply insert the item:
</p><p>
<pre><code>if ( mgr->applman->uidMan()->isFinalised() )
    mgr->init( mgr->applman->uidMan() );
else
    mgr->applman->uidMan()->finalised.notify(mCB(mgr,uiHelloMgr,init));
</pre></code>
</p><p>
Because callbacks can only be sent to objects that are <code>CallBacker</code>s, we have made an object <code>uiHelloMgr</code> that can receive the callback from the menu.
</p>
<h4>The <code>uiHelloMgr</code></h4>
<p>
The uiHelloMgr will receive a callback when the ui manager is finalised: the <code>init(CallBacker*)</code> method is then called. In that method the ui hello manager inserts the menu item into the menu. It tells the menu item to call the dispMsg method when triggered:
</p><p>
<code><pre>applman->utilMnu()->insertItem(
      new uiMenuItem( "&amp;Diplay Hello Message ...",
                      mCB(this,uiHelloMgr,dispMsg) );
</code></pre>
</p><p>
The <code>uiHelloMgr::dispMsg</code> method does nothing more than make an instantiation of the dialog class we made for showing the message: <code>uiHelloMsgBringer</code>.
</p>
<h4>The <code>uiHelloMsgBringer</code></h4>
<p>
The <code>uiHelloMsgBringer</code> class is a <code>uiDialog<code> which means it has (by default) Ok and Cancel buttons, a window title, and so forth. The class contains a field for user input of the string to display as message. To make the example a bit lively, we added a field whether the message should be, eh, just a message, or a warning. You can see the <code>uiGenInput</code> class will serve both input fields nicely, you just need to define another <code>InpSpec</code> instance:
<code><pre>txtfld = new uiGenInput( this, "Hello message",
                                    StringInpSpec("Hello world") );
    typfld = new uiGenInput( this, "Message type",
                             BoolInpSpec("Info","Warning") );
    typfld->attach( alignedBelow, txtfld );
</code></pre>
</p><p>
Note that "Hello world" is the inital string displayed in <code>txtfld</code>. Another feature of the OpendTect UI is the automatic layout: we program the positions of the various fields by attaching them in certain ways - most commonly <code>alignedBelow</code>.
</p><p>
The actual message is displayed when the user presses Ok on the dialog that pops up. When nothing is filled in, we give the user the finger with the "Please type a text" message, and we do not accept the Ok, i.e. the dialog remains on the screen and the user can either be a good girl (or boy) and fill in something or press cancel.
<code><pre>if ( ! *typedtxt )
{
    uiMSG().error( "Please type a text" );
    return false;
}
</code></pre>
</p><p>
When a message is present, we do as we're told:
</p><p>
<code><pre>if ( typfld->getBoolValue() )
    uiMSG().message( typedtxt );
else
    uiMSG().warning( typedtxt );
return true;
</code></pre>
</p><p>
and the dialog disappears immediately after the message appears on the screen.

</p>

<br>
<br>
<a name=coh><h3>Attributes: Coherency</h3>

<a name=cohintro><h4>Intro</h4>
<p>
Anyone vaguely familiar with interpretation should by now know about Coherency abd Coherency cubes. We have always used the 'Similarity' attribute instead because of patent restrictions. Similarity is just as good for object detection en better suited in combination with the dip/steering concept. Coherency beats Similarity when used for single-attribute display.
</p><p>
The Coherency attributes were implemented some time ago by Kristofer for his research work, and it seemed a good idea to show how to make your own attribute plugins by looking at the <code>Coh</code> and <code>uiCoh</code> plugin code.
</p>

<a name=cohrw><h4>The <code>Coh</code> plugin</h4>
<p>
The <code>Coh</code> plugin handles the 'Real Work' part. If we start with the plugin 'main' file, <code>uicohpi.cc</code>, we see that it's not that much more complex than the <code>hellopi.cc</code> from the <code>Hello</code> plugin. There are three includes:
<code>#include "coh.h"</code> gets the Coherency attribute object classes;
<code>#include "attribfact.h"</code> gets the attribute factory to which the Coherency attributes must be added;
<code>#include "plugins.h"</code> is needed for the PluginInfo structure and the PI_AUTO_INIT_EARLY define:

<pre><code>extern "C" int GetCohPluginType()
{
    return PI_AUTO_INIT_EARLY;
}</code></pre>
</p><p>
The above is one of the three 'special' plugin functions that determine how OpendTect will deal with the plugin. The GetxxxxPluginType() function is used for detemining whether and when to <a href=#autoload>auto-load</a> the plugin.
</p><p>
This particular plugin tells OpendTect's application manager that it wants to be loaded early - i.e. before any build of tables, data structures or user interfaces are made. That is typical of 'Real Work' plugins. The alternatives are NONE (which is default so in that case a GetxxxxPluginType() need not be defined and LATE, which is typical for UI plugins that want to start working when most of the widgets are already created.
</p><p>
A few lines further we get:
<pre><code>extern "C" PluginInfo* GetCohPluginInfo()
{
    static PluginInfo retpii = {
        "Coherency",
        "dGB - Kristofer Tingdahl and Bert Bril",
        "1.0.1",
        "Coherency attribute plugin.\n\n"
        "Usage of Coherency may be subject to patent laws!" };
    return &retpii;
}</code></pre>
If you look at the definition of PluginInfo, this should be easy to grasp. It allows the plugin manager to make this info about the plugin available to the world.
</p><p>
The actual work is done, like in the Hello world plugin, in:
<pre><code>extern "C" const char* InitCohPlugin( int, char** )
{
    AF().add( new CoherencyAttrib::Parameters, false );
    return 0; // All OK - no error messages
}</code></pre>
This function gets passed argc and argv from the main function. It should return null on success, and an error message if the initialisation failed. In this case, the Coherency attribute is added to AF() (the <a href="Generated/AttribEng/classAttribFactory.html">AttribFactory</a> singleton access function) using the macro defined in attribfact.h .
</p>

<a name=cohrw><h4>Making attributes</h4>
<p>
Although cohpi.cc looks pretty simple, underneath the simple <code>AF().add</code> there is of course some real programming of the attribute. For that, we need to switch to coh.h . We see an attribute <code>CoherencyAttrib</code> inheriting the <a href="Generated/AttribEng/classAttribCalc.html">AttribCalc</a> class. Then immediately an enormous macro (in OpendTect macros can often be recognised by the leading 'm') <code>mAttrib5Param</code> which defines the parameters of the attribute. Compare this to what you see in Opendtect in the attribute definition window after loading the uiCoh plugin.
</p><p>
If you look at the parts of the definition carefully, you'll see that each parameter is built up with:
<ul>
<li>xxxxAttribParameter - the type of the parameter
<li>the name of the parameter
<li>Required, Default (or Disabled)
<li>The default value
<li>The allowed values
</ul>
</p><p>
Most of the rest of the methods are there to comply with the <code>AttribCalc</code> interface - see the <a href="Generated/AttribEng/classAttribCalc.html">AttribCalc documentation</a>. The basic idea is that for each sample of each trace one or more attribute values can be calculated. The number of attribute values (or outputs) is defined by the <code>nrAttribs()</code> function. The name of each out is set in <code>attribName(int)</code>. If your input requires additional samples (timegate) or neighbouring traces (stepout), you will have to define <code>reqInterval</code> and <code>reqStepout</code> respectively.
</p><p>
On the implementation side of all that, we have some overhead and the actual attribute calculation. If you feel that the overhead is enormous, bear in mind that the Attribute engine will let the attribute work on any part of any input cube or on the output of another attribute, and that things are cut in pieces when multiple processors are available. And there's more but the idea is that all that requires some extra work when making the attributes.
</p><p>
When we want to look at the actual work, the place to be is the <code>nextStep()</code> method of the <code>CoherencyAttrib::Task</code> class. This class inherits the <code>MultiThreadBasicTask</code> class - see <a href="Generated/Basic/classMultiThreadBasicTask.html">MultiThreadBasicTask documentation</a> for more information. The reason for this task setup is that there may be many tasks for each attribute calculation, and in this way they can be run simultaneously.
</p><p>
But before the work can be done, some input has to be given. The <code>CoherencyAttrib::Task::Input</code> class is designed for that. The <code>set</code> function is the keyfunction in this class, and is called for each trace to be calculated. It should select the necessary data from the input attributes, present in the set of <code>AttribProvider</code>s. For the Coherency this is the seismic data and the imaginairy data calculated by the <code>Hilbert</code> attribute. But it can also be Steering Data or any other attribute.</p>
See example from <code>CoherencyAttrib</code>:
<pre><code>
xxxxAttrib::Task::Input::set( const BinID& pos,
                     const ObjectSet<AttribProvider>& inputproviders,
                     const TypeSet<int>& inputattribs,
                     const TypeSet<float*>&)
{
    const BinID& stepout = calculator.stepout;

    for ( int idx=-stepout.inl; idx<=stepout.inl; idx++ )
    {
        for ( int idy=-stepout.crl; idy<=stepout.crl; idy++ )
        {
            SeisTrc* trc = inputproviders[0]->getTrc(   pos.inl + idx,
                                                        pos.crl + idy);
            if ( !trc ) return false;
            retrcs->set(idx+stepout.inl,idy+stepout.crl, trc);

            trc = inputproviders[1]->getTrc(    pos.inl + idx,
                                                pos.crl + idy);
            if ( !trc ) return false;
            imtrcs->set(idx+stepout.inl,idy+stepout.crl, trc);
        }
    }

    attribute = inputproviders[0]->attrib2component( inputattribs[0] );
    imattribute = inputproviders[1]->attrib2component( inputattribs[1] );

    return true;
}
</code></pre>

<p>
The <code>CoherencyAttrib::Task</code> class also has a <code>set</code> function. This function is used to transfer some specific information about the trace to be processed, like the starttime, the number of samples you wish to calculate, the timestep, a pointer to the input and a pointer to the output. The output is a set containing pointers to all ouputs defined in <code>CoherencyAttrib</code>.</p>
Example:
<pre><code>  
xxxxAttrib::Task::set( float start, int nrsamples, float step_, 
     		       const AttribCalc::Task::Input* input_, 
		       const TypeSet<float*>& output )
{
    t1 = start;
    nrtimes = nrsamples;
    step = step_;
    input = input_;
    cohptr = output[0];
    inldipptr = output[1];
    crldipptr = output[2];
}
</code></pre>

<p> 
When your machine has multiple processors, the <code>getFastestSz()</code> function can be of importance. E.g. on a two processor machine, there will be two tasks, one for the lower part of the trace and one for the higher part of the trace. The more porcessors you have the smaller the number of samples per part will be. A minimum number of samples per part can be specified by <code>getFastestSz()</code>, the default value is 25 samples. 
Now it's time for the <code>nextStep()</code> function to do it's work. This is the place where you define the mathematics for calculating the attribute. This function is called for each trace of your output cube.
</p>

<br>
<a name=autoload><h2>Installation and auto-loading</h2>

<p>
Once you have made your own plugin, you probably would like it to be loaded automatically whenever OpendTect is started. 
OpendTect provides some facilities that do just that.
</p>

<h3>Preparing a plugin for auto-load</h3>
If you want to prepare your plugin for auto-loading at startup, you basically just have to define when it should be loaded. This is done by implementing the GetxxxxPluginType() function, for example:
</p><p>

<pre><code>
#include "plugins.h"

extern "C" int GetCohPluginType()
{
    return PI_AUTO_INIT_EARLY;
}
</code></pre>

</p><p>
<code>#include "plugins.h"</code> is needed for the PluginInfo structure and the PI_AUTO_INIT_xxx defines.
</p><p>

The GetxxxxPluginType() specifies when a plugin is loaded: 
<li>PI_AUTO_INIT_EARLY : Plugin is loaded before construction of main window</li>
<li>PI_AUTO_INIT_LATE : Plugin is loaded after construction of main window</li>


<h3>Installing plugins for auto-load</h3>

<p>
The auto-load tool of OpendTect looks for plugins to load in two places:
</p>

<li>The plugins/platform_dir of the installation directory (<code>$DTECT_APPL/plugins/$HDIR</code>)</li>
<li>The '.od' directory in your 'Personal directory' <code>($HOME/.od/plugins/$HDIR</code> on Unix)</li>

<p>
On Windows, your 'Personal directory' is located at $HOMEDRIVE/$HOMEPATH if this is defined and not "C:\".
Otherwise, the location of the special windows folder "Application Data" is used. Also see the specific notes in the <a href="windows.html#installplugins">windows</a> documentation.

<h4>Sub-directories</h4>
<p>
Once you have located (and/or made) the directory where the plugins should be stored, you have 3 options of installing the plugins:
</p>
<li>Just install them in the $HDIR subdir.</li>
<li>Make a subdir 'libs' to contain the plugins and use .alo files. (V1.0.3 and up)</li>
<li>Make a subdir '&lt;program name&gt;' for each program that uses the plugin and install the plugins there.</li>
</p><p>
The first option causes the plugins to be loaded in all programs that support OpendTect plugins, 
while the last option requires managing multiple copies of the plugins under Windows, because Windows does not support symbolic linking. Therefore, the preferred method is to make use of .alo files.
</p>

<h4>Using .alo files</h4>

<p>
Auto LOad files are simple text files that tell a program which plugins it is supposed to load from the 'libs' directory.
Since OpendTect contains multiple programs, each program has its own set of .alo files '&lt;program name&gt;.*.alo', while the plugins can be shared between multiple programs.

</p><p>

Since there are multiple vendors and/or plugin sets, each vendor can make his own .alo files. DtectMain, for example, will look at any file named dtectmain.*.alo. For this example, the default plugins are specified by dtectmain.base.alo, while dgb's plugins are specified by dtectmain.dgb.alo. This way, each vendor can make his own .alo files, without interfering with others.

</p><p>
An .alo file is nothing more then a simple list of plugins, without extensions. For example, this is what dtectmain.base.alo files look like:
</p>

<pre><code>
uiSeisIOSimple
</code></pre>

<p>
Note that for each platform, a specific .alo file must be created. Usually, they will be the same, but some plugins might not (yet) be supported on all platforms.

</p>

<h4>Order of loading</h4>

<p>

The non-alo plugins will be loaded in alphabetical order. For .alo files the
order is as specified in the file. The alo files themselves are handled in
alphabetical order.

</p>


<br>
<a name=dist><h2>Distributing your plugins:</h2>

<p>
The publishing and distribution of OpendTect plugins is pretty straightforward, especially if you use .alo files. The .alo files can be installed in the plugins/platform (<code>$DTECT_APPL/plugins/$HDIR</code>) directory, while the actual plugins come in the 'libs' sub-directory.
</p>
<p>
On Unix, this means that you can make a .tar.gz file containing the plugins in a directory structure as described above, which can be extracted into the existing OpendTect installation directory.
</p><p>
On Windows this is also possible, but it is more common to use an auto-extracting installer to do this.
For more info on this, see the <a href="windows.html#dist">windows</a> documentation.
</p>
<br>
<img src="../hr.png" border=0>

<p>
<center>
  <a href="index.html">Index</a>
| <a href="overview.html">Overview</a>
| <a href="pmake.html">Pmake</a>
| <a href="windows.html">MS Windows</a>
| <a href="http://www.opendtect.org">opendtect.org</a>
</center>
</p>

</body>
</html>
