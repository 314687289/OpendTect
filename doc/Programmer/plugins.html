<html>
<!--
  - CopyRight:	(C) dGB Earth Sciences
  - Author:	A.H. Bril
  - Date:	Oct 2003
  - Contents:	Plugins
  - RCS:	$Id: plugins.html,v 1.30 2005-12-02 08:37:43 nanne Exp $
 -->

<body background="../backg.png"><title>Plugins [OpendTect Programmer's manual V2.1]</title>
<center>
<h1>OpendTect Plugins</h1>
  <a href=#intro>Intro</a>
| <a href=#concept>Concept</a>
| <a href=#mnudlg>Menu and Dialog</a>
| <a href=#coh>Coherency</a>
| <a href=#autoload>Installation and auto-loading</a>
</center>
<br>
<img src="../hr.png" border=0>

<a name=intro><h2>Intro</h2>
<h3>Background</h3>

<p> Making your own software within OpendTect is in principle pretty
easy. You <i>could</i> change the software by modifying existing
classes and functions, and adding your own stuff to the libs. The
advantage is total control. The problem with this approach, however,
is that you have to keep the OpendTect sources in sync with new
releases. Furthermore, if you cannot convince the opendtect.org people
to also make those changes, OpendTect users may not be happy with your
work. </p>

<p> An easy way to overcome this is to make your own plugins. Plugins
make use of all the facilities of OpendTect but are loaded at run-time
and can therefore be developed in a completely independent way. If you
then find things that can't be done without modifying the OpendTect
environment, it should be much easier to convince the opendtect.org
people to take over or even implement those things themselves. </p>

<p> One thing you <i>cannot</i> do, is use another compiler than
<b>gcc/g++</b>. OpendTect is built with it, if you want to use another
compiler (why?) you'll have to make all libs and supporting libs (Qt,
COIN, fftw) yourself. The make itself should be pretty easy to get
started, but there will probably be some porting to do, too. </p>

<br><br>
<a name=concept><h2>The concept</h2>
<h3>Dynamic loading</h3>

<p> All modern Operating systems nowadays have ways to dynamically
load libraries into a running program. The basic idea is:</p>

<ul>
<li>Open the library
<li>Query the contents for a certain routine using a string key
<li>Call the routine returned
<li>The routine then does the things needed to make itself useful.
</ul>


<p> As an example, a 'hello world' program could conceptually look
like this:

<pre><code>

dynlib = OpenDynamicLib( "libc.so" );
PrintfTypeFunction fn = (PrintfTypeFunction)GetDynLibFn( dynlib, "printf" );
fn( "Hello world\n" );

</code></pre>
</p>

<p> In this very simple case calling the function has no other effect
than printing a string. In OpendTect, you'd want to add an attribute,
create a menu item in the Opendtect menu, etc. etc. </p>

<h3>OpendTect plugins</h3>

<p> In OpendTect, all of the dynamic lib querying etc. is already
programmed. A plugin just needs to contain a few standard functions
that will be called automatically when the dynamic library is loaded.
There are three functions, of which only one is really required. Let's
say the name of the plugin is MyMod, these functions will be: </p>

<pre><code>GetMyModPluginType
GetMyModPluginInfo
InitMyModPlugin
</code></pre>

<p> Only the last one is required. The first one,
<code>Get...PluginType</code> determines whether the plugin can be
used for the <a href=#autoload>auto-load</a>, and if so, when. 'When'
means: before or after the program has created the OpendTect GUI
objects (and always after the static objects are initialised). The
second function simply provides info for the users of your plugin.
</p>

<p> Note that these functions must be declared 'extern "C"', as you
can see in the first example plugin "Hello": </p>

<pre><code>#include &lt;iostream&gt;
extern "C" const char* InitHelloPlugin( int, char** )
{
    std::cout &lt;&lt; "Hello world" &lt;&lt; std::endl;
    return 0; // All OK - no error messages
}
</code></pre>

<p> You'll find this example plugin in the plugins directory of your
work environment. Those 6 lines are enough to constitute a plugin for
OpendTect. The Makefile to build the plugin looks like this: </p>

<p>
<pre><code>SRC.cc := hellopi.cc
PLUGIN := yes
include make.od.Defaults
include make.Targets
</code></pre>
</p>

<p> First try <code>make -n</code> (make sure you have <a
href="pmake.html">Pmake</a> initialised!). Notice that Pmake makes an
awful lot of commands with a small specification. Anyway, after typing
<code>make</code> the plugin should be generated. The new plugin can
be loaded from within OpendTect (Menu Utilities-Plugins; press the
'Load new' button). At that point in time, the message 'Hello world'
should appear on stdout (on Windows, stdout messages appear on the
OpendTect console window). </p>

<p> To make this a UI - based program we'll need to use functionality
from the <code>uiBase</code> module. In this case, we use the
<code>uiMSG()</code> utility: </p>


<pre><code>#include "uimsg.h"
extern "C" const char* InituiHelloPlugin( int*, char** )
{
    uiMSG().message( "Hello world" );
    return 0; // All OK - no error messages
}
</code></pre>

<p> Again 6 lines, but now, when you load it, you'll get a popup
message with an OK button. </p>

<p>In this case we actually use stuff from OpendTect libraries, so the
Makefile needs to change. We need to add the line:

<pre><code>MODDEP := uiBase </code></pre>

Notice that this is added <i>before</i> the
inclusions: It's a directive to establish all kinds of variables in
the make includes. By typing <code>make -n</code> again you'll see
that Pmake added some directives for the compiler. </p>

<br>
<a name=real><h2>Realistic examples</h2>

<a name=mnudlg><h3>Menu and Dialog</h3>

<h4>Intro</h4>

<p> Adding menu items popping up your own dialogs is pretty easy once
you get the hang of it. The uiArkCls plugin is a good example: it
shows how to get hold of the parent menus, and what to do to get the
CallBacks. You don't need to download the doc.arkcls however because
the uiHello plugin code contains some example code to make things
clear. Although we fear that you might be scared by this code when you
first see it, we hope that after the explanations below you will see
some beauty in it and start to like it. </p>

<p> Look in uihellopi.cc - the PLAN_B part. First of all, we nicely
define the other standard plugin functions:

<pre><code>extern "C" int GetuiHelloPluginType()
{
    return PI_AUTO_INIT_LATE;
}

extern "C" PluginInfo* GetuiHelloPluginInfo()
{
    static PluginInfo retpi = {
        "uiHello plugin - plan B",
        "Bert",
        "1.1.1",
        "This is the more extensive variant of the uiHello example.\n"
        "See the plugin manual for details." };
    return &retpi;
}
</pre></code>

The plugin will now <a href=#autoload>auto-load</a> when put in the
correct plugins directory. </p>

<p> The idea is to add a menu item 'Display Hello Message ...' to the
'Utilities' menu of OpendTect. The Makefile and the example code are
already prepared for this, you only need to define 'PLAN_B', for
example on the command line:

<code><pre>make PLAN_B=yes</code></pre>

 Apart from adding a flag so we can check for PLAN_B in the code, the
<code>MODDEP := uiODMain</code> tells Pmake that the
<code>uiODMain</code> headers, and the headers <code>uiODMain</code>
depends on will be used. That is much more than the original
<code>uiBase</code> dependencies. uiODMain is the top level of
OpendTect.

</p>

<p> If <code>"make PLAN_B=yes"</code> does not compile anything
(because a uiHello.so already exists), you can try "<code>make
uihellopi.rmlib</code>" first. </p>

<h4>Problems</h4>

The two problems we are faced with are:

<ol>
<li>How to add a new menu item
<li>How to create a dialog
</ol>

<p> The real problem behind the first is not so much how to make the
item itself, but how to get hold of the parent menu it must be
inserted into. This is a threshold that needs to be conquered for
every new system: you'll need an entry point, a seed to get you going.
In OpendTect, the entry point is the global instance of the uiODMain
class that can be accessed through the <code>uiODMain*
ODMainWin()</code> global function. Once you have that, you can reach
any object you need.</p>

<p> To see where things start, go to the PLAN_B InituiHelloPlugin
function at the bottom of uihellopi.cc to find: </p>

<pre><code>extern "C" const char* InituiHelloPlugin( int, char** )
{
    (void)new uiHelloMgr( ODMainWin() );
    return 0; // All OK - no error messages
}
</pre></code>

<p> As you can see, the ODMainWin() instance is passed to a new
instance of <code>uiHelloMgr</code> which is programmed in the lines
above it. This Manager object is needed as you will find that any
non-trivial GUI plugin will need some kind of top-level 'application
management' object to drive it. </p>

<h4>The <code>uiHelloMgr</code></h4>

<p> An important part of any GUI system is callback handling. In
OpendTect, callbacks are basic objects used throughout the system, not
only in the User Interface. In any case, because callbacks can only be
sent to objects that are <code>CallBacker</code>s, we have made
<code>uiHelloMgr</code> a descendent of <code>CallBacker</code>, so it
can receive the callback from the menu. When the uiHelloMgr is
constructed, it will add a menu item to the OpendTect menu: </p>

<code><pre>
    uiMenuItem* newitem = new uiMenuItem( "&amp;Diplay Hello Message ...",
                                          mCB(this,uiHelloMgr,dispMsg) );
    appl.menuMgr().utilMnu()->insertItem( newitem );
</code></pre>

<p> The new menu item is defined by the display text (the '&amp;'
makes the 'D' the shortcut key) and the CallBack that needs to be
called when the item is activated (by the user). Note the
<code>mCB</code> which is a macro that makes the rather difficult C++
notation easy to understand. See callback.h in the <code>Basic</code>
include directory if you're really interested. </p>

<p> The next line inserts the item into the 'Utilities' menu. You'll
find a bunch of methods in the <code>uiODMenuMgr</code> class to
access all menus and toolbars. </p>

<h4>The <code>uiHelloMsgBringer</code></h4>

<p> All dialog windows in OpendTect are objects of type
<code>uiDialog</code> (in a few cases like the OpendTect main window
itself they descend from <code>uiMainWin</code>). The
<code>uiHelloMsgBringer</code> class is such a <code>uiDialog</code>
which means it has (by default) Ok and Cancel buttons, a window title,
and so forth. The class contains a field for user input of the string
to display as message. To make the example a bit lively, we added a
field whether the message should be, eh, just a message, or a warning.
You can see the <code>uiGenInput</code> class will serve both input
fields nicely, you just need to define another <code>InpSpec</code>
instance: </p>

<code><pre>txtfld = new uiGenInput( this, "Hello message",
                         StringInpSpec("Hello world") );
typfld = new uiGenInput( this, "Message type",
                         BoolInpSpec("Info","Warning") );
typfld->attach( alignedBelow, txtfld );
</code></pre>

<p> Note that "Hello world" is the inital string displayed in
<code>txtfld</code>. Another feature of the OpendTect UI is the
automatic layout: we program the positions of the various fields by
attaching them in certain ways - most commonly
<code>alignedBelow</code>. </p>

<p> The actual message is displayed when the user presses Ok on the
dialog that pops up. When nothing is filled in, we give the user the
finger with the "Please type a text" message, and we do not accept the
Ok, i.e. the dialog remains on the screen and the user can either be a
good girl (or boy) and fill in something or press cancel.</p>

<code><pre>if ( ! *typedtxt )
{
    uiMSG().error( "Please type a message text" );
    return false;
}
</code></pre>

<p> When a message is present, we do as we're told: </p>


<code><pre>if ( typfld->getBoolValue() )
    uiMSG().message( typedtxt );
else
    uiMSG().warning( typedtxt );
return true;
</code></pre>


<p> and the dialog disappears immediately after the message appears on
the screen. </p>

<br>
<br>
<a name=coh><h3>Attributes: Coherency</h3>

<a name=cohintro><h4>Intro</h4>

<p> Anyone vaguely familiar with interpretation by now knows about
Coherency and Coherency cubes. We have always used the 'Similarity'
attribute instead because of patent restrictions. Similarity is just
as good for object detection en better suited in combination with the
dip/steering concept. Coherency beats Similarity when used for
single-attribute display. </p>

<p> The Coherency attributes were implemented some time ago by
Kristofer for his research work, and it seemed a good idea to show how
to make your own attribute plugins by looking at the <code>Coh</code>
and <code>uiCoh</code> plugin code. </p>

<a name=cohrw><h4>The <code>Coh</code> plugin</h4>

<p> The <code>Coh</code> plugin handles the 'Real Work' part. If we
start with the plugin 'main' file, <code>cohpi.cc</code>, we see
that it's not that much more complex than the <code>hellopi.cc</code>
from the <code>Hello</code> plugin. There are tow includes:
<code>#include "coherencyattrib.h"</code> gets the Coherency attribute object
classes; <code>#include "plugins.h"</code> is needed for the PluginInfo
structure and the PI_AUTO_INIT_EARLY define: </p>

<pre><code>extern "C" int GetCohPluginType()
{
    return PI_AUTO_INIT_EARLY;
}</code></pre>

<p> The above is one of the three 'special' plugin functions that
determine how OpendTect will deal with the plugin. The
GetxxxxPluginType() function is used for determining whether and when
to <a href=#autoload>auto-load</a> the plugin. </p>

<p> This particular plugin tells OpendTect's application manager that
it wants to be loaded early - i.e. before any build of tables, data
structures or user interfaces are made. That is typical of 'Real Work'
plugins. The alternatives are NONE (which is default so in that case a
GetxxxxPluginType() need not be defined) and LATE, which is typical
for UI plugins that want to start working when all objects have
already been created. </p>

<p> A few lines further we get:</p>

<pre><code>
extern "C" PluginInfo* GetCohPluginInfo()
{
    static PluginInfo retpii = {
        "Coherency",
        "dGB - Kristofer Tingdahl and Bert Bril",
        "=od",
        "Coherency attribute plugin.\n\n"
        "Usage of Coherency may be subject to patent laws!" };
    return &retpii;
}
</code></pre>

<p> If you look at the definition of PluginInfo, this should be easy
to grasp. It allows the plugin manager to make this info about the
plugin available to the world. </p>

<p> The actual work is done, like in the Hello world plugin, in:</p>


<pre><code>
extern "C" const char* InitCohPlugin( int, char** )
{
    Attrib::Coherency::initClass();
    return 0; // All OK - no error messages
}
</code></pre>

<p> This function initializes the attribute, the initClass() function will be 
explained in more detail in the following part</p>

<a name=cohrw><h4>Making attributes</h4>

<p> Although cohpi.cc looks pretty simple, underneath the simple
<code>initClass()</code> there is of course some real programming of the
attribute. For that, we need to switch to coherencyattrib.h . 
We see an attribute <code>CoherencyAttrib</code> inheriting the <a
href="Generated/AttributeEngine/classAttrib_1_1Provider.html">Attrib::Provider</a> 
class. Every attribute is a provider, each can thus be used as input for 
another attribute.

<p>Some fundamental functions are listed here:</p>
<a name=cohrw><h5>initClass()</h5>
<p> This static function initializes the attribute: sets up the parameters and 
the number and type of the inputs and outputs. You can compare this to what you see in Opendtect in the attribute definition window after loading the uiCoh 
plugin.</p>

<p> If you look at the parts of the implementation carefully, 
( coherencyattrib.cc ) you'll see that each parameter is built up following 
that example: </p>

<pre><code>
ZGateParam* gate = new ZGateParam( gateStr() );
gate->setLimits( Interval&lt;float&gt;(-mUndefValue, mUndefValue) );
gate->setDefaultValue( Interval&lt;float&gt;(-40,40) );
gate->setRequired(false);
desc->addParam( gate );
</code></pre>

<p>where xxxParam is the type of the parameter.</p>
<p>of course the default values and the limits are optional.</p>
<p>Every parameter is required by default, to overrule this use <code>setRequired(false)"</p>

<p>initClass() also adds the attribute to the attribute factory.
In this case, as every attribute is a provider, the Coherency attribute is 
added to PF() (the <a href="Generated/AttributeEngine/classAttrib_1_1ProviderFactory.html"
>Attrib::ProviderFactory</a> singleton access function).</p>


<a name=cohrw><h5>createInstance()</h5>
<p>This function is standard for every attribute, 
here is the attribute constructor called.</p>


<a name=cohrw><h5>updateDesc()</h5>
<p>Will be used not only to update the parameters but also the number and type 
of the outputs and to add or disable some inputs. If you look at the 
implementation for the coherency, this function just allows to enable or disable
the second input ( hidden hilbert transform ) according to the type chosen
by the user</p>


<a name=cohrw><h5>getInputOutput()</h5>
<p>Here you can specify the outputs you need for calculation among all those provided by your input data;</p>


<a name=cohrw><h5>getInputData();</h5>
<p>Before the work can be done, some input has to be given. This function is the
place where you specify how to get your input data.
For the Coherency this is the seismic data and the imaginairy data calculated 
by the <code>Hilbert</code> attribute. But it can also be Steering Data or any 
other attribute. let's have a look at the abstract of code below:</p>

<pre><code>
const BinID bidstep = inputs[0]->getStepoutStep();
    if ( type==1 )
    {
	while ( inputdata.size() &lt; 3 )
	    inputdata += 0;

	const DataHolder* datac = inputs[0]->getData( relpos, idx );
	const DataHolder* datai =
	   inputs[0]->getData( BinID(relpos.inl+bidstep.inl,relpos.crl), idx );
	const DataHolder* datax =
           inputs[0]->getData( BinID(relpos.inl,relpos.crl+bidstep.crl), idx );
	if ( !datac || !datai || !datax )
	  return false;

      realidx_ = getDataIndex( 0 );
      inputdata.replace( 0, datac );
      inputdata.replace( 1, datai );
      inputdata.replace( 2, datax );
    }
</code></pre>

<p> You will notice from here that the calculation of the attributes is not done
on traces but using a different object, the DataHolder. The dataholder contains
a set of <a href="Generated/Basic/classValueSeries.html">ValueSeries</a> which 
holds the value of every sample of the SeisTrc.
Advantage: in case of an attribute which has other attributes as inputs, data 
is available in the corresponding dataholders, it thus saves a lot of time 
( easier and much faster to read some floats in a ValueSeries than to get values
from a SeisTrc ). Stored data are read from cubes of seismic traces and written
the same way.</p>
<p>The DataHolder is also carrying some specific information about the trace to
be processed, like the start sample number and the number of samples you wish 
to calculate.</p>
<p>Another important remark: calculation is made using sample numbers, 
not time or depth</p>

<p> Most of the rest of the methods are there to comply with the
<code>Attrib::Provider</code> interface - see the <a
href="Generated/AttributeEngine/classAttrib_1_1Provider.html">Attrib::Provider
documentation</a>. The basic idea is that for each sample of each
trace one or more attribute values can be calculated. The number of
attribute values (or outputs) is defined in the <code>initClass()</code> 
function. If your input requires additional samples (timegate) or neighbouring 
traces (stepout), you will have to define <code>reqZMargin()</code> and 
<code>reqStepout()</code> respectively. </p>


<p> When we want to look at the actual work, the place to be is the
<code><b>computeData()</b></code> method. This is the place where you define the
mathematics for calculating the attribute. This function is called for each 
trace of your output cube.</p>


<a name=cohui><h4>The <code>uiCoh</code> plugin</h4>

<p> There are special classes for the attribute parameters user
interfaces. This is because they: </p>


<ul>
<li>have a lot in common
<li>have to be displayed in the Attribute Set Editor window
<li>need to be able to do the right things at the right moment
</ul>

<p>In uicoherencyattrib.h you can see that <code>uiCoherencyAttrib</code>
inherits from <code>uiAttrDescEd</code> - the base class for all
attribute parameter UI groups.</p>

<p> The <code>uiAttrDescEd</code> class delivers services to its
children, but it also sets a couple of requirements:</p>

<ul>
<li>setParameters (required)
<li>setInput (required)
<li>getParameters(required)
<li>getInput (required)
<li>setOutput (required if you have more than one possible output)
<li>getOutput (required if you have more than one possible output)
<li>getEvalParams (optional)
</ul>

<p> These methods must be defined by subclasses. To implement these
methods there are services like fillInp and putInp. </p>

<p> In the uicoherencyattrib.cc file we see that although
<code>uiAttrDescEd</code> is not a <code>uiDialog</code> like the the
uiHello example, it still is a valid parent (being a
<code>uiGroup</code>) for the various UI elements. A nice feature of
OpendTect is clear from the first line in the constructor: the
<code>inpfld</code> is a special Attribute UI class which is handled
just like any pre-defined uiBase or <code>uiTools</code> class. This
illustrates that in the OpendTect GUI system, not only pre-made GUI
elements are 'first class' - new objects with different shape and
behavior attached will be usable transparently by any other GUI class.
</p>

<p> Further on the specific uiAttrdescEd methods, we take the example
of <code>uiCoherencyAttrib::setParameters</code>. Here we get access to the 
<code>desc</code> that is currently being edited. 
In this case, the attribute set editor wants us to take the values from the 
desc and put them on the screen. 
Thus, we have to check whether there is something in the first place (macro
<code>mIfGetxxx</code>, where xxx stands for the type of the parameter), and if
so, put the value into the corresponding UI element. For inputs to this 
attribute (input cubes or other attributes), there is a special <code>setInput()</code> method.</p>

<p> The <code>getParameters</code> method's implementation
follows similar patterns. Here we read the values from the screen and put them into the desc. Underneath we make use of the change tracker
to update the pars - this allows the set editor to figure out whether
the attribute set was changed (and subsequently warn the user when no
save has beeen done). In the same way the input and output are handled by <code>getInput()</code> and <code>getOutput()</code> respectively.</p>

<p>A special function is <code>getEvalParams</code>. In this function, the user can add parameters to the given set of <code>EvalParam</code>'s.
When added, the set editor knows that attribute evaluations can be done with this parameter. In this case, the user can evaluate the effect of time gate differences by using the special button. </p>

<p> The funny thing is that uicoherencyattrib.cc stops without 'doing' anything.
That's because the attribute set editor object is 'doing' everything.
Some people will want to call this an example of the <i>Hollywood
principle</i> - 'Don't call us - we'll call you'. </p>

<p> Anyway, lastly, the uicohpi.cc is dead simple. It's a LATE plugin
because you'd want the rest of the UI already in place. The only
interesting part is the part where the new <code>AttrDescEd</code> is
added to the <code>uiAttribFactory</code>. 


<br>
<a name=autoload><h2>Installation and auto-loading</h2>

<p> Once you have made your own plugin, you probably would like it to
be loaded automatically whenever OpendTect is started. OpendTect
provides some facilities that do just that. </p>

<h3>Preparing a plugin for auto-load</h3>

<p>If you want to prepare your plugin for auto-loading at startup, you
basically just have to define when it should be loaded. This is done
by implementing the GetxxxxPluginType() function, for example: </p>

<p><pre><code>
#include "plugins.h"

extern "C" int GetCohPluginType()
{
    return PI_AUTO_INIT_EARLY;
}
</code></pre></p>

<p><code>#include "plugins.h"</code> is needed for the PluginInfo
structure and the PI_AUTO_INIT_xxx defines. </p>

<p>

The GetxxxxPluginType() specifies when a plugin is loaded: 

<li>PI_AUTO_INIT_EARLY : Plugin is loaded before construction of main
window</li>

<li>PI_AUTO_INIT_LATE : Plugin is loaded after construction of main
window</li>

</p>

<h3>Installing plugins for auto-load</h3>

<p> The auto-load tool of OpendTect looks for plugins to load in two
places: </p>

<li>The plugins/platform_dir of the installation directory
(<code>$DTECT_APPL/plugins/$HDIR</code>)</li>

<li>The '.od' directory in your 'Personal directory'
<code>($HOME/.od/plugins/$HDIR</code> on Unix)</li>

<p> On Windows, your 'Personal directory' is located at $HOME if this
is defined. Otherwise, $USERPROFILE is used. Also see the specific
notes in the <a href="windows.html#installplugins"> windows</a>
documentation. </p>

<h4>Sub-directories</h4>

<p>Once you have located (and/or made) the directory where the
plugins should be stored, you have 3 options of installing the
plugins:</p>

<li>Just install them in the $HDIR subdir.</li>

<li>Make a subdir 'libs' to contain the plugins and use .alo
files.</li>

<li>Make a subdir '&lt;program name&gt;' for each program that uses
the plugin and install the plugins there.</li>

<p>The first option causes the plugins to be loaded in all programs
that support OpendTect plugins,  while the last option requires
managing multiple copies of the plugins under Windows, because Windows
does not support symbolic linking. Therefore, the preferred method is
to make use of .alo files. </p>

<h4>Using .alo files</h4>

<p>Auto LOad files are simple text files that tell a program which
plugins it is supposed to load from the 'libs' directory. Since
OpendTect contains multiple programs, each program has its own set of
.alo files '&lt;program name&gt;.*.alo', while the plugins can be
shared between multiple programs. OpendTect will scan for any file
with this naming convention. So odmain.john.alo is perfectly OK.</p>

<p>Since there are multiple vendors and/or plugin sets, each vendor
can make his own .alo files. DtectMain, for example, will look at any
file named odmain.*.alo. For this example, the default plugins are
specified by odmain.base.alo, while dgb's plugins are specified by
odmain.dgb.alo. This way, each vendor can make his own .alo files,
without interfering with others.</p>

<p>An .alo file is nothing more then a simple list of plugins, without
extensions. For example, this is what odmain.base.alo files look like:
</p>

<pre><code>
uiSeisIOSimple
</code></pre>

<p> Note that for each platform, a specific .alo file must be created.
Usually, they will be the same, but some plugins might not (yet) be
supported on all platforms. </p>

<h4>Order of loading</h4>

<p>The non-alo plugins will be loaded in alphabetical order. For .alo
files the order is as specified in the file. The alo files themselves
are handled in alphabetical order. </p>


<br>
<a name=dist><h2>Distributing your plugins:</h2>

<p> The publishing and distribution of OpendTect plugins is pretty
straightforward, especially if you use .alo files. The .alo files can
be installed in the plugins/platform
(<code>$DTECT_APPL/plugins/$HDIR</code>) directory, while the actual
plugins come in the 'libs' sub-directory. </p>

<p> On Unix, this means that you can make a .tar.gz file containing
the plugins in a directory structure as described above, which can be
extracted into the existing OpendTect installation directory. </p>

<p> On Windows this is also possible, but it is more common to use an
auto-extracting installer to do this. For more info on this, see the
<a href="windows.html#dist">windows</a> documentation. </p>

<br>
<img src="../hr.png" border=0>

<p>
<center>
  <a href="index.html">Index</a>
| <a href="overview.html">Overview</a>
| <a href="pmake.html">Pmake</a>
| <a href="unix.html">UNIX</a>
| <a href="windows.html">MS Windows</a>
| <a href="http://www.opendtect.org">opendtect.org</a>
</center>
</p>

</body>
</html>
