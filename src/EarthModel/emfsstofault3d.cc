/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        J.C. Glas
 Date:          March 2009
________________________________________________________________________

-*/
static const char* rcsID = "$Id: emfsstofault3d.cc,v 1.6 2009-07-22 16:01:31 cvsbert Exp $";

#include "emfsstofault3d.h"

#include "survinfo.h"
#include "emfaultstickset.h"
#include "emfault3d.h"


namespace  EM
{


FSStoFault3DConverter::FaultStick::FaultStick( int sticknr )
	: sticknr_(sticknr)
	, pickedonplane_(false)
	, normal_(Coord3::udf())
{}


double FSStoFault3DConverter::FaultStick::slope( double zscale ) const
{
    if ( crds_.size()<2 )
	return mUdf(double);

    double basedist = Coord(crds_[0]).distTo( crds_[crds_.size()-1] );
    if ( mIsZero(basedist,mDefEps) )
	return MAXDOUBLE;

    return fabs( zscale*(crds_[0].z-crds_[crds_.size()-1].z) / basedist );
}


Coord3 FSStoFault3DConverter::FaultStick::findPlaneNormal() const
{
    const int maxdist = 5;
    int oninl = 0; int oncrl = 0; int ontms = 0;

    for ( int idx=0; idx<crds_.size()-1; idx++ )
    {
	const BinID bid0 = SI().transform( crds_[idx] );
	for ( int idy=idx+1; idy<crds_.size(); idy++ )
	{
	    const BinID bid1 = SI().transform( crds_[idy] );
	    const int inldist = abs( bid0.inl-bid1.inl );
	    if ( inldist < maxdist )
		oninl += maxdist - inldist;
	    const int crldist = abs( bid0.crl-bid1.crl );
	    if ( crldist < maxdist )
		oncrl += maxdist - crldist;
	    const int zdist = mNINT( fabs(crds_[idx].z-crds_[idy].z) /
			              fabs(SI().zStep()) );
	    if ( zdist < maxdist )
		ontms += maxdist - zdist;
	}
    }

    if ( ontms==oninl && ontms==oncrl )
	return Coord3::udf();
    if ( ontms>=oncrl && ontms>=oninl )
	return Coord3( 0, 0, 1 );
    if ( oninl == oncrl )
	return Coord3( Coord::udf(), 0 );

    return oncrl>oninl ? Coord3( SI().binID2Coord().colDir(), 0 ) :
			 Coord3( SI().binID2Coord().rowDir(), 0 );
}


bool FSStoFault3DConverter::FaultStick::pickedOnInl() const
{
    return pickedonplane_ && normal_.isDefined() &&
	   fabs(Coord(normal_).dot(SI().binID2Coord().rowDir()))>0.5;
}


bool FSStoFault3DConverter::FaultStick::pickedOnCrl() const
{
    return pickedonplane_ && normal_.isDefined() &&
	   fabs(Coord(normal_).dot(SI().binID2Coord().colDir()))>0.5;
}


bool FSStoFault3DConverter::FaultStick::pickedOnTimeSlice() const
{
    return pickedonplane_ && normal_.isDefined() && fabs(normal_.z)>0.5;
}


FSStoFault3DConverter::Setup::Setup()
    : pickplanedir_(Setup::Auto)
    , sortsticks_(true)
    , zscale_(SI().zScale())
    , stickslopethres_(mUdf(double))
    , useinlcrlslopesep_(false)
    , stickseldir_(Setup::Auto)
{
}

FSStoFault3DConverter::FSStoFault3DConverter( const Setup& setup,
					      const FaultStickSet& fss,
					      Fault3D& f3d )
    : setup_(setup)
    , fss_(fss)
    , fault3d_(f3d)
    , curfssg_(0)
{
}


bool FSStoFault3DConverter::convert()
{
    fault3d_.removeAll();
    bool selhorpicked;

    for ( int sidx=0; sidx<fss_.nrSections(); sidx++ )
    {
	const int sid = fss_.sectionID( sidx );
	readSection( sid );

	if ( !sidx )
	    selhorpicked = preferHorPicked();

	selectSticks( selhorpicked );
		
	if ( setup_.sortsticks_ )
	    geometricSort( selhorpicked ? MAXDOUBLE : 0.0 );

	untwistSticks( setup_.zscale_ );
	resolveUdfNormals();
	writeSection( sid );
	deepErase( sticks_ );
    }

    return true;
}


bool FSStoFault3DConverter::readSection( const SectionID& sid )
{
    if ( fss_.sectionIndex(sid) < 0 )
	return false;
    mDynamicCast( const Geometry::FaultStickSet*, curfssg_,
		  fss_.sectionGeometry(sid) );
    if ( !curfssg_ )
	return false;
    const StepInterval<int> rowrg = curfssg_->rowRange();
    if ( rowrg.isUdf() )
	return false;

    RowCol rc;
    for ( rc.row=rowrg.start; rc.row<=rowrg.stop; rc.row+=rowrg.step )
    {
	const StepInterval<int> colrg = curfssg_->colRange( rc.row );
	if ( colrg.isUdf() )
	    return false;

	FaultStick* stick = new FaultStick( rc.row );
	sticks_ += stick;

	for ( rc.col=colrg.start; rc.col<=colrg.stop; rc.col+=colrg.step )
	{
	    const Coord3 pos = curfssg_->getKnot( rc );
	    if ( !pos.isDefined() )
		return false;
	    stick->crds_ += pos;
	}

	stick->pickedonplane_ = fss_.geometry().pickedOnPlane( sid, rc.row );
	if ( stick->pickedonplane_ )
	    stick->normal_ = stick->findPlaneNormal();
	else
	    stick->normal_ = curfssg_->getEditPlaneNormal( rc.row );
    }
    return true;
}


bool FSStoFault3DConverter::preferHorPicked() const
{
    if ( setup_.pickplanedir_ == Setup::Horizontal )
	return true;
    if ( setup_.pickplanedir_ == Setup::Vertical )
	return false;

    int nrpickedontimeslice = 0;
    for ( int idx=0; idx<sticks_.size(); idx++ )
    {
	if ( sticks_[idx]->pickedOnTimeSlice() )
	    nrpickedontimeslice++;
    }

    return nrpickedontimeslice > sticks_.size()/2;
}


#define insertSorted( slope, slopelist ) \
{ \
    if ( slopelist.isEmpty() || slope >= slopelist[slopelist.size()-1 ] ) \
	slopelist += slope; \
    else \
	for ( int slopeidx=0; slopeidx<slopelist.size(); slopeidx++ ) \
	{ \
	    if ( slope <= slopelist[slopeidx] ) \
	    { \
		slopelist.insert( slopeidx, slope ); \
		break; \
	    } \
	} \
}\


void FSStoFault3DConverter::selectSticks( bool selhorpicked )
{
    for ( int idx=sticks_.size()-1; idx>=0; idx-- )
    {
	if ( sticks_[idx]->pickedOnTimeSlice() != selhorpicked )
	    delete sticks_.remove( idx );
    }
    if ( selhorpicked )
	return;

    bool useinlcrlsep = setup_.useinlcrlslopesep_;
    double slopethres = setup_.stickslopethres_;
    bool inlsteeper;

    if ( useinlcrlsep )
    {
	TypeSet<double> inlslopes;
	TypeSet<double> crlslopes;
	for ( int idx=0; idx<sticks_.size(); idx++ )
	{
	    const double slope = sticks_[idx]->slope( setup_.zscale_ );
	    if ( !mIsUdf(slope) && sticks_[idx]->pickedOnInl() )
		insertSorted( slope, inlslopes ); 
	    if ( !mIsUdf(slope) && sticks_[idx]->pickedOnCrl() )
		insertSorted( slope, crlslopes ); 
	}
	const int inlsz = inlslopes.size();
	const int crlsz = crlslopes.size();

	if ( inlslopes.isEmpty() || crlslopes.isEmpty() )
	    useinlcrlsep = false;
	else
	{
	    inlsteeper = inlslopes[ inlsz/2 ] > crlslopes[ crlsz/2 ];

	    if ( mIsUdf(slopethres) )
	    {
		slopethres = inlsteeper ? (inlslopes[0]+crlslopes[crlsz-1])/2 :
					  (crlslopes[0]+inlslopes[inlsz-1])/2; 
	    }
	}
    }

    if ( mIsUdf(slopethres) )
	return;

    bool selhorsticks = setup_.stickseldir_==Setup::Horizontal;
    if ( setup_.stickseldir_ == Setup::Auto )
    {
	int horvertbalance = 0;
	for ( int idx=0; idx<sticks_.size(); idx++ )
	{
	    const double slope = sticks_[idx]->slope( setup_.zscale_ );
	    if ( !mIsUdf(slope) )
		horvertbalance += slope<fabs(slopethres) ? -1 : 1;
	}
	if ( horvertbalance < 0 )
	    selhorsticks = true;
    }		

    for ( int idx=sticks_.size()-1; idx>=0; idx-- )
    {
	const FaultStick& stick = *sticks_[idx];
	if ( useinlcrlsep && (stick.pickedOnInl() || stick.pickedOnCrl()) )
	{
	    if ( (stick.pickedOnInl() && inlsteeper==selhorsticks) ||
		 (stick.pickedOnCrl() && inlsteeper!=selhorsticks) )
	    {
		delete sticks_.remove( idx );
		continue;
	    }
	    if ( mIsUdf(setup_.stickslopethres_) )
		continue;
	}

	const double slope = stick.slope( setup_.zscale_ );
	if ( !mIsUdf(slope) && (slope<fabs(slopethres)) != selhorsticks )
	    delete sticks_.remove( idx );
    }
}


void FSStoFault3DConverter::geometricSort( double zscale )
{
    TypeSet<int> sticknrs;

    for ( int idx=0; idx<sticks_.size(); idx++ )
	sticknrs += sticks_[idx]->sticknr_;

    if ( curfssg_ )
	curfssg_->geometricStickOrder( sticknrs, zscale, false );

    for ( int idy=sticknrs.size()-1; idy>0; idy-- )
    {
	for ( int idx=0; idx<sticks_.size(); idx++ )
	{
	    if ( sticks_[idx]->sticknr_ == sticknrs[idy] )
	    {
		sticks_.swap( idx, idy );
		break;
	    }
	}
    }
}


void FSStoFault3DConverter::untwistSticks( double zscale )
{
    bool reverse = false;
    for ( int idx=1; idx<sticks_.size(); idx++ )
    {

	if ( curfssg_ && curfssg_->isTwisted(sticks_[idx-1]->sticknr_,
					     sticks_[idx]->sticknr_, zscale) )
	    reverse = !reverse;

	if ( reverse )
	{
	    const int nrknots = sticks_[idx]->crds_.size();
	    for ( int idy=0; idy<nrknots/2; idy++ )
		sticks_[idx]->crds_.swap( idy, nrknots-1-idy );
	}
    }
}


void FSStoFault3DConverter::resolveUdfNormals()
{
    for ( int idx=0; idx<sticks_.size(); idx++ )
    {
	Coord3& normal = sticks_[idx]->normal_;
	if ( normal.isDefined() )
	    continue;

	for ( int idy=(idx ? idx-1 : idx+1); idy<sticks_.size(); idy++ )
	{
	    Coord3& adjacentnormal = sticks_[idy]->normal_;
	    if ( !adjacentnormal.isDefined() )
		continue;
	    if ( mIsUdf(normal.z) || normal.z==adjacentnormal.z )
	    {
		normal = adjacentnormal;
		break;
	    }
	}
	if ( !normal.isDefined() )
	    normal = Coord3( SI().binID2Coord().rowDir(), 0 );
    }	
}


bool FSStoFault3DConverter::writeSection( const SectionID& sid ) const
{
    if ( sticks_.isEmpty() )
	return false;

    fault3d_.geometry().addSection( fss_.sectionName(sid), sid, false );

    int sticknr = sticks_[0]->sticknr_;
    for ( int idx=1; idx<sticks_.size(); idx++ )
    {
	if ( sticks_[idx]->sticknr_ < sticknr )
	    sticknr = sticks_[idx]->sticknr_;
    }

    for ( int idx=0; idx<sticks_.size(); idx++ )
    {
	const FaultStick* stick = sticks_[idx];
	if ( stick->crds_.isEmpty() )
	    continue;

	if ( !fault3d_.geometry().insertStick(sid, sticknr, 0, stick->crds_[0],
		    			      stick->normal_, false) )
	    continue;

	for ( int crdidx=1; crdidx<stick->crds_.size(); crdidx++ )
	{
	    const RowCol rc( sticknr, crdidx );
	    fault3d_.geometry().insertKnot( sid, rc.getSerialized(),
					    stick->crds_[crdidx], false );
	}

	sticknr++;
    }

    return fault3d_.geometry().nrSticks( sid );
}



}; // namespace EM
