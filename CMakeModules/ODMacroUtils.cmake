#_______________________Pmake__________________________________________________
#
#	CopyRight:	dGB Beheer B.V.
# 	Jan 2012	K. Tingdahl
#	RCS :		$Id: ODMacroUtils.cmake,v 1.56 2012-05-16 05:39:11 cvsranojay Exp $
#_______________________________________________________________________________

# OD_INIT_MODULE - Marcro that setups a number of variables for compiling
#		   OpendTect.
#
# Input variables:
# 
# OD_MODULE_NAME			: Name of the module, or the plugin
# OD_SUBSYSTEM                          : "od" or "dgb"
# OD_MODULE_DEPS			: List of other modules that this
#					  module is dependent on.
# OD_MODULE_SOURCES			: Sources that should go into the library
# OD_USEPROG				: Whether to include include/Prog 
# OD_USECOIN				: Dependency on Coin is enabled if set.
# OD_USEQT				: Dependency on Qt is enabled if set.
#					  value should be either Core, Sql, Gui
#					  or OpenGL
# OD_USEZLIB				: Dependency on zlib is enabled if set.
# OD_USEOSG				: Dependency on OSG is enabled if set.
# OD_IS_PLUGIN				: Tells if this is a plugin (if set)
# OD_PLUGINMODULES			: A list of eventual sub-modules of
#					  a plugin. Each submodule must have an
#					  plugins/{OD_MODULE_NAME}/src/${PLUGINMODULE}/CMakeFile.txt
#####################################
#
# Output variables:
#
# OD_${OD_MODULE_NAME}_INCLUDEPATH 	: The path(s) to the headerfiles of the
#					  module. Normally one single one, but
#					  may have multiple paths in plugins.
# OD_${OD_MODULE_NAME}_DEPS		: The modules this module is dependent
#					  on.
# OD_${OD_MODULE_NAME}_RUNTIMEPATH	: The runtime path for its own library, 
#					  and all external libraries it is
#					  dependent on.
# OD_MODULE_NAMES_${OD_SUBSYSTEM}	: A list of all modules
# OD_CORE_MODULE_NAMES_${OD_SUBSYSTEM}  : A list of all non-plugin modules
#####################################
#
# Internal variables
#
# OD_MODULE_INCLUDEPATH		: The includepath needed to compile the source-
#				  files of the module.
# OD_MODULE_RUNTIMEPATH		: All directories that are needed at runtime
# OD_MODULE_INTERNAL_LIBS	: All OD libraries needed for the module
# OD_MODULE_EXTERNAL_LIBS	: All external libraries needed for the module

MACRO( OD_INIT_MODULE )

SET ( OD_MODULE_HAS_LIBRARY ${OD_MODULE_SOURCES} )

#Add this module to the list
IF ( OD_MODULE_HAS_LIBRARY )
    SET( OD_MODULE_NAMES_${OD_SUBSYSTEM} ${OD_MODULE_NAMES_${OD_SUBSYSTEM}}
					 ${OD_MODULE_NAME} PARENT_SCOPE )

    #Create init-header 
    #OD_CREATE_INIT_HEADER()
ENDIF(  OD_MODULE_HAS_LIBRARY )

#Add all module dependencies
SET( OD_${OD_MODULE_NAME}_DEPS ${OD_MODULE_DEPS} )

#Setup all deps and set runtime and includepath
IF( OD_MODULE_DEPS )
    OD_GET_ALL_DEPS( ${OD_MODULE_NAME} OD_MODULE_INTERNAL_LIBS )
    FOREACH( DEP ${OD_MODULE_INTERNAL_LIBS} )
	#Add dependencies to include-path
	LIST(APPEND OD_MODULE_INCLUDEPATH ${OD_${DEP}_INCLUDEPATH} )
	LIST(APPEND OD_MODULE_RUNTIMEPATH ${OD_${DEP}_RUNTIMEPATH} )
    ENDFOREACH()
ENDIF()


IF(OD_USECOIN)
    OD_SETUP_COIN()
ENDIF()

IF( UNIX AND OD_USEZLIB )
    LIST(APPEND OD_MODULE_INCLUDEPATH ${ZLIB_INCLUDE_DIR} )
    LIST(APPEND OD_MODULE_EXTERNAL_LIBS ${ZLIB_LIBRARY} )
ENDIF()

IF(OD_USEOSG)
    OD_SETUP_OSG()
ENDIF()

#Add Qt-stuff
IF(OD_USEQT)
   OD_SETUP_QT()
ENDIF(OD_USEQT)

#Add current module to include-path
IF ( OD_MODULE_HAS_LIBRARY )
    IF (OD_IS_PLUGIN)
	SET( PLUGINDIR ${CMAKE_SOURCE_DIR}/plugins/${OD_MODULE_NAME})
	LIST( APPEND OD_${OD_MODULE_NAME}_INCLUDEPATH ${PLUGINDIR})
	FOREACH( OD_PLUGINSUBDIR ${OD_PLUGINMODULES} )
	    LIST(APPEND OD_${OD_MODULE_NAME}_INCLUDEPATH
		${PLUGINDIR}/include/${OD_PLUGINSUBDIR})
	    INCLUDE(${PLUGINDIR}/src/${OD_PLUGINSUBDIR}/CMakeLists.txt)
	ENDFOREACH()

	# Record alo-entries
	IF ( NOT DEFINED OD_NO_ALO_ENTRY )
	    SET( OD_ALO_NAME ${OD_MODULE_NAME} )
	    OD_ADD_ALO_ENTRIES( ${OD_PLUGIN_ALO_EXEC} )
	ENDIF()
    ELSE()
	SET( OD_CORE_MODULE_NAMES_${OD_SUBSYSTEM}
	     ${OD_CORE_MODULE_NAMES_${OD_SUBSYSTEM}}
		${OD_MODULE_NAME} PARENT_SCOPE )
	LIST(APPEND OD_${OD_MODULE_NAME}_INCLUDEPATH
	    ${CMAKE_SOURCE_DIR}/include/${OD_MODULE_NAME} )
    ENDIF(OD_IS_PLUGIN)

    #Add all headerfiles to be included in the library (nice in IDEs)
    FOREACH ( INCDIR ${OD_${OD_MODULE_NAME}_INCLUDEPATH} )
	FILE ( GLOB INCFILES ${INCDIR}/*.h )
	IF ( INCFILES )
	    LIST ( APPEND OD_MODULE_INCFILES ${INCFILES} )
	ENDIF( INCFILES )
    ENDFOREACH()

ENDIF ( OD_MODULE_HAS_LIBRARY )


SET ( OD_${OD_MODULE_NAME}_RUNTIMEPATH ${OD_EXEC_OUTPUT_PATH} )
guess_runtime_library_dirs( EXTERNAL_RUNTIMEPATH ${OD_MODULE_EXTERNAL_LIBS} )
LIST(APPEND OD_${OD_MODULE_NAME}_RUNTIMEPATH ${EXTERNAL_RUNTIMEPATH} )
LIST(APPEND OD_MODULE_INCLUDEPATH ${OD_${OD_MODULE_NAME}_INCLUDEPATH} )
LIST(APPEND OD_MODULE_RUNTIMEPATH ${OD_${OD_MODULE_NAME}_RUNTIMEPATH} )

#Clean up the lists
LIST(REMOVE_DUPLICATES OD_MODULE_INCLUDEPATH)
IF(  OD_MODULE_RUNTIMEPATH )
    LIST(REMOVE_DUPLICATES OD_MODULE_RUNTIMEPATH)
ENDIF()

IF ( OD_MODULE_HAS_LIBRARY )
    #Export dependencies
    SET( OD_${OD_MODULE_NAME}_DEPS ${OD_MODULE_DEPS} PARENT_SCOPE )
    SET( OD_${OD_MODULE_NAME}_INCLUDEPATH
	 ${OD_${OD_MODULE_NAME}_INCLUDEPATH} PARENT_SCOPE)
    SET( OD_${OD_MODULE_NAME}_RUNTIMEPATH
	 ${OD_${OD_MODULE_NAME}_RUNTIMEPATH} PARENT_SCOPE)
ENDIF( OD_MODULE_HAS_LIBRARY )

#Extract static libraries
FOREACH( STATIC_LIB ${OD_MODULE_STATIC_LIBS} )
    GET_FILENAME_COMPONENT( STATIC_LIB_NAME ${STATIC_LIB} NAME )
    SET( STATIC_LIB_DIR
         ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${OD_MODULE_NAME}.dir/${STATIC_LIB_NAME}.dir )
    SET ( SHARED_LIB_COMMAND ${CMAKE_AR} x ${STATIC_LIB} )
    IF ( NOT EXISTS ${STATIC_LIB_DIR} )
	FILE( MAKE_DIRECTORY ${STATIC_LIB_DIR} )
    ENDIF()

    EXECUTE_PROCESS( 
	COMMAND ${SHARED_LIB_COMMAND}
	WORKING_DIRECTORY ${STATIC_LIB_DIR} )

    FILE( GLOB STATIC_LIB_FILES ${STATIC_LIB_DIR}/*.o )
    LIST( APPEND OD_STATIC_OUTFILES ${STATIC_LIB_FILES} )

    add_custom_command( OUTPUT ${STATIC_LIB_FILES}
	        COMMAND ${SHARED_LIB_COMMAND}
                WORKING_DIRECTORY ${STATIC_LIB_DIR}
		DEPENDS ${STATIC_LIB}
                COMMENT "Extracting shared library ${STATIC_LIB_NAME}" )

    FOREACH ( STATIC_LIB_FILE ${STATIC_LIB_FILES} )
	set_property( DIRECTORY APPEND
		PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${STATIC_LIB_FILE} )
    ENDFOREACH()

ENDFOREACH()

#Setup library & its deps
IF( OD_MODULE_HAS_LIBRARY AND OD_LIB_LINKER_NEEDS_ALL_LIBS )
    SET( OD_LIB_DEP_LIBS ${EXTRA_LIBS} ${OD_MODULE_DEPS} )
    IF ( NOT OD_SUBSYSTEM MATCHES ${OD_CORE_SUBSYSTEM} )
	LIST( APPEND OD_LIB_DEP_LIBS ${OD_MODULE_INTERNAL_LIBS} )
    ENDIF()
ELSE()
    SET( OD_EXEC_DEP_LIBS ${EXTRA_LIBS} ${OD_MODULE_INTERNAL_LIBS} )
ENDIF()

IF ( OD_MODULE_HAS_LIBRARY )
    ADD_LIBRARY( ${OD_MODULE_NAME} SHARED ${OD_MODULE_SOURCES}
		 ${QT_MOC_OUTFILES}
		 ${OD_MODULE_INCFILES}
		 ${OD_STATIC_OUTFILES} )
    TARGET_LINK_LIBRARIES(
	    ${OD_MODULE_NAME}
	    ${OD_LIB_DEP_LIBS}
	    ${OD_MODULE_EXTERNAL_LIBS}
	 )

    SET_TARGET_PROPERTIES( ${OD_MODULE_NAME}
	    PROPERTIES 
	    LINK_FLAGS "${OD_PLATFORM_LINK_OPTIONS} ${OD_MODULE_LINK_OPTIONS}"
	    ARCHIVE_OUTPUT_DIRECTORY "${OD_EXEC_OUTPUT_PATH}" 
	    LIBRARY_OUTPUT_DIRECTORY "${OD_EXEC_OUTPUT_PATH}"
	    RUNTIME_OUTPUT_DIRECTORY "${OD_EXEC_OUTPUT_PATH}")

    INSTALL(TARGETS
	    ${OD_MODULE_NAME}
	    RUNTIME DESTINATION ${OD_EXEC_INSTALL_PATH} 
	    LIBRARY DESTINATION ${OD_EXEC_INSTALL_PATH}
	    ARCHIVE DESTINATION lib )

    OD_SIGN_TARGET( ${OD_MODULE_NAME} )
ENDIF ( OD_MODULE_HAS_LIBRARY )

#Setup common things for batch-programs
IF( OD_MODULE_PROGS OR OD_MODULE_BATCHPROGS OR OD_MODULE_GUI_PROGS )
    SET ( OD_RUNTIMELIBS ${OD_MODULE_DEPS})
    IF ( OD_MODULE_HAS_LIBRARY )
	LIST ( APPEND OD_RUNTIMELIBS ${OD_MODULE_NAME} )
    ENDIF ( OD_MODULE_HAS_LIBRARY )
    SET ( OD_USEPROG 1 )
ENDIF()

#Add executable targets
IF( OD_MODULE_PROGS OR OD_MODULE_GUI_PROGS )

    FOREACH( EXEC ${OD_MODULE_PROGS} ${OD_MODULE_GUI_PROGS} )
	GET_FILENAME_COMPONENT( TARGET_NAME ${EXEC} NAME_WE )

	#Check if from GUI list
	LIST ( FIND OD_MODULE_GUI_PROGS ${EXEC} INDEX )
	IF ( NOT ${INDEX} EQUAL -1 )
	    SET( OD_EXEC_GUI_SYSTEM ${OD_GUI_SYSTEM} )
	ENDIF()

	IF ( ${TARGET_NAME} MATCHES od_main_console )
	SET( EXEC od_main )
	ENDIF()

	ADD_EXECUTABLE( ${TARGET_NAME} ${OD_EXEC_GUI_SYSTEM} ${EXEC} 
			${OD_${EXEC}_RESOURCE} )
	SET_TARGET_PROPERTIES( ${TARGET_NAME}
	    PROPERTIES 
	    LINK_FLAGS "${OD_PLATFORM_LINK_OPTIONS} ${OD_MODULE_LINK_OPTIONS}"
	    RUNTIME_OUTPUT_DIRECTORY "${OD_EXEC_OUTPUT_PATH}")
	TARGET_LINK_LIBRARIES(
	    ${TARGET_NAME}
	    ${OD_EXEC_DEP_LIBS}
	    ${OD_RUNTIMELIBS} )
        IF( OD_CREATE_LAUNCHERS )
	    create_target_launcher( ${TARGET_NAME}
		RUNTIME_LIBRARY_DIRS
		${OD_MODULE_RUNTIMEPATH}
		${OD_EXEC_OUTPUT_PATH}
		ENVIRONMENT
		DTECT_APPL=${OD_BINARY_BASEDIR}
		WORK=${OD_BINARY_BASEDIR})
        ENDIF( OD_CREATE_LAUNCHERS )
	INSTALL(TARGETS
		${TARGET_NAME}
		RUNTIME DESTINATION ${OD_EXEC_INSTALL_PATH} 
		LIBRARY DESTINATION ${OD_EXEC_INSTALL_PATH}
		ARCHIVE DESTINATION lib )

	OD_SIGN_TARGET( ${TARGET_NAME} )
    ENDFOREACH()

ENDIF()

IF(OD_MODULE_BATCHPROGS)
    #Add dep on Batch if there are batch-progs
    IF ( OD_MODULE_BATCHPROGS )
	LIST( APPEND OD_RUNTIMELIBS "Batch" "Network" )
	LIST( REMOVE_DUPLICATES OD_RUNTIMELIBS )
    ENDIF()


    FOREACH( EXEC ${OD_MODULE_BATCHPROGS} )
	GET_FILENAME_COMPONENT( TARGET_NAME ${EXEC} NAME_WE )
	ADD_EXECUTABLE( ${TARGET_NAME} ${EXEC} )
	TARGET_LINK_LIBRARIES(
	    ${TARGET_NAME}
	    ${OD_EXEC_DEP_LIBS}
	    ${OD_RUNTIMELIBS} )
	SET_TARGET_PROPERTIES( ${TARGET_NAME}
	    PROPERTIES 
	    COMPILE_DEFINITIONS __prog__
	    LINK_FLAGS "${OD_PLATFORM_LINK_OPTIONS} ${OD_MODULE_LINK_OPTIONS}"
	    RUNTIME_OUTPUT_DIRECTORY "${OD_EXEC_OUTPUT_PATH}")
	IF( OD_CREATE_LAUNCHERS )
	    create_target_launcher( ${TARGET_NAME}
		RUNTIME_LIBRARY_DIRS
		${OD_MODULE_RUNTIMEPATH} )
	ENDIF( OD_CREATE_LAUNCHERS )
	INSTALL(TARGETS
		${TARGET_NAME}
		RUNTIME DESTINATION ${OD_EXEC_INSTALL_PATH} 
		LIBRARY DESTINATION ${OD_EXEC_INSTALL_PATH}
		ARCHIVE DESTINATION lib )
	OD_SIGN_TARGET( ${TARGET_NAME} )
    ENDFOREACH()

ENDIF(OD_MODULE_BATCHPROGS)

IF(OD_USEPROG)
    LIST(APPEND OD_MODULE_INCLUDEPATH
		${OpendTect_DIR}/include/Prog)
ENDIF( OD_USEPROG )


#Set current include_path
INCLUDE_DIRECTORIES( ${OD_MODULE_INCLUDEPATH} )

ENDMACRO(OD_INIT_MODULE)

# OD_GET_ALL_DEPS( MODULE LISTNAME ) - dumps all deps to MODULE into LISTNAME
MACRO( OD_GET_ALL_DEPS MODULE DEPS )
    FOREACH( DEPLIB ${OD_${MODULE}_DEPS} )
	OD_GET_ALL_DEPS_ADD( ${DEPLIB} ${DEPS} )
    ENDFOREACH()
ENDMACRO( OD_GET_ALL_DEPS )

MACRO( OD_GET_ALL_DEPS_ADD DEP DEPLIST )
    LIST ( FIND ${DEPLIST} ${DEP} INDEX )
    IF ( ${INDEX} EQUAL -1 )
        LIST ( APPEND ${DEPLIST} ${DEP} )
        FOREACH( DEPLIB ${OD_${DEP}_DEPS} )
            OD_GET_ALL_DEPS_ADD( ${DEPLIB} ${DEPLIST} )
        ENDFOREACH()
    ENDIF()

ENDMACRO ( OD_GET_ALL_DEPS_ADD )



# OD_ADD_PLUGIN_SOURCES(SOURCES) - Adds sources in a submodule of a plugin
#
# Input variables:
# 
# OD_PLUGINSUBDIR			: Name sub-module of the plugin
# SOURCES				: List of sources to add
#
# Output:
# OD_MODULE_SOURCES

MACRO ( OD_ADD_PLUGIN_SOURCES )
    FOREACH( SRC ${ARGV} )
	LIST( APPEND OD_MODULE_SOURCES src/${OD_PLUGINSUBDIR}/${SRC} )
    ENDFOREACH()
ENDMACRO()

# OD_ADD_PLUGIN_EXECS(SOURCES) - Adds sources in a submodule of a plugin
#
# Input variables:
# 
# OD_PLUGINSUBDIR			: Name sub-module of the plugin
# SOURCES				: List of sources to add
#
# Output:
# OD_MODULE_PROGS

MACRO ( OD_ADD_PLUGIN_EXECS )
    FOREACH( SRC ${ARGV} )
	LIST( APPEND OD_MODULE_PROGS src/${OD_PLUGINSUBDIR}/${SRC} )
    ENDFOREACH()
ENDMACRO()


# OD_ADD_PLUGIN_BATCHPROGS(SOURCES) - Adds sources in a submodule of a plugin
#
# Input variables:
# 
# OD_PLUGINSUBDIR			: Name sub-module of the plugin
# SOURCES				: List of sources to add
#
# Output:
# OD_MODULE_BATCHPROGS

MACRO ( OD_ADD_PLUGIN_BATCHPROGS )
    FOREACH( SRC ${ARGV} )
	LIST( APPEND OD_MODULE_BATCHPROGS src/${OD_PLUGINSUBDIR}/${SRC} )
    ENDFOREACH()
ENDMACRO()


# In a list of libraries, such as
# "debug"
# <debuglib>
# "optimized"
# <optimizedlib>
# this macro will get the one that will be used in the current config
#
# USAGE: OD_GET_USED_LIBRARY( LIST OUTPUTVAR )
#
MACRO( OD_GET_USED_LIBRARY )
    SET ( LIBLIST ${ARGV} )
    LIST ( LENGTH LIBLIST SIZE )
    IF ( ${SIZE} LESS 2 )
	MESSAGE( FATAL_ERROR "Invalid size" )
    ENDIF()
    MATH ( EXPR OUTPUTNR "${SIZE} -1" )
    LIST ( GET LIBLIST ${OUTPUTNR} OUTPUT )
    LIST ( REMOVE_AT LIBLIST ${OUTPUTNR} )

    IF ( OD_DEBUG )
	LIST ( FIND LIBLIST "debug" INDEX )
	IF ( NOT ${INDEX} EQUAL -1 )
	    MATH( EXPR INDEX "${INDEX} + 1" )
	    LIST ( GET LIBLIST ${INDEX} ${OUTPUT} )
	ENDIF()
    ENDIF()

    IF ( NOT EXISTS ${${OUTPUT}} )
	LIST ( FIND LIBLIST "optimized" INDEX )
	IF ( NOT ${INDEX} EQUAL -1 )
	    MATH( EXPR INDEX "${INDEX} + 1" )
	    LIST ( GET LIBLIST ${INDEX} ${OUTPUT} )
	ENDIF()
    ENDIF()

    IF ( NOT EXISTS ${${OUTPUT}} )
	LIST ( GET LIBLIST 0 ${OUTPUT} )
    ENDIF()

ENDMACRO()


# Adds an external library, copies it into output directory. Returns
# copied filename.
# Input library can be a list, such as:
# "debug"
# <debuglib>
# "optimized"
# <optimizedlib>
#
# USAGE: OD_IMPORT_LIBRARY( LIBRARYLIST PATH_TO_USED_LIB )
#

MACRO ( OD_IMPORT_LIBRARY )
    SET ( LIBLIST ${ARGV} )
    LIST ( LENGTH LIBLIST SIZE )
    MATH ( EXPR OUTPUTNR "${SIZE} -1" )
    LIST ( GET LIBLIST ${OUTPUTNR} OUTTARGET )
    LIST ( REMOVE_AT LIBLIST ${OUTPUTNR} )

    OD_GET_USED_LIBRARY( ${LIBLIST} _USEDLIB )

    IF ( NOT EXISTS ${_USEDLIB} )
	MESSAGE( FATAL_ERROR "${_USEDLIB} not found" )
    ENDIF()

    GET_FILENAME_COMPONENT( LIBNAME ${_USEDLIB} NAME )
    SET ( OUTFILE "${OD_EXEC_OUTPUT_PATH}/${LIBNAME}" )
    SET ( ${OUTTARGET} "${OUTFILE}" )

    EXECUTE_PROCESS( COMMAND ${CMAKE_COMMAND} -E create_symlink ${_USEDLIB} ${OUTFILE} )
ENDMACRO()
